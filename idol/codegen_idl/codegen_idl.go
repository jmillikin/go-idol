// Copyright (c) 2024 John Millikin <john@john-millikin.com>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
// OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// SPDX-License-Identifier: 0BSD

// Code generated by idol-codegen-go. DO NOT EDIT.
// source: idol/idl/codegen.idol

package codegen_idl

import (
	binary_ "encoding/binary"
	fmt_ "fmt"
	io_ "io"
	iter_ "iter"
	unsafe_ "unsafe"

	"go.idol-lang.org/idol"

	import_0_ "go.idol-lang.org/idol/schema_idl"
)

type CodegenRequest struct{ msg idol.DecodedMessage }

type _CodegenRequest__Message struct {
	idol.IsGeneratedMessage[CodegenRequest]
	self CodegenRequest
}

type _CodegenRequest__MessageType struct {
	idol.IsGeneratedMessageType[CodegenRequest]
}

func (m CodegenRequest) Idol__Message() idol.Message[CodegenRequest] {
	return _CodegenRequest__Message{self: m}
}

func (CodegenRequest) Idol__MessageType() idol.MessageType[CodegenRequest] {
	return _CodegenRequest__MessageType{}
}

func (m _CodegenRequest__Message) Self() CodegenRequest { return m.self }

func (m _CodegenRequest__Message) Type() idol.MessageType[CodegenRequest] {
	return _CodegenRequest__MessageType{}
}

func (m _CodegenRequest__Message) Size() uint32 { return m.self.msg.Size() }

func (m _CodegenRequest__Message) Fields() idol.MessageFields {
	return _CodegenRequest__MessageFields{m.self}
}

func (m _CodegenRequest__Message) Clone() idol.MessageBuilder[CodegenRequest] {
	b := &CodegenRequest__Builder{}
	if m.self.msg.Has(1) {
		b.Schema.Set(idol.Clone(m.self.Schema()).Self())
	}
	b.Dependencies.Extend(m.self.Dependencies())
	b.PluginOptions.Extend(m.self.PluginOptions())
	return b.Idol__MessageBuilder()
}

type _CodegenRequest__MessageFields struct {
	self CodegenRequest
}

func (f _CodegenRequest__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "schema"
	case 2:
		return "dependencies"
	case 3:
		return "plugin_options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _CodegenRequest__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _CodegenRequest__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Schema()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Dependencies()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.PluginOptions()) {
			return
		}
	}
}

func (_CodegenRequest__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Message(1, (import_0_.Schema{}).Idol__MessageType().Decode)
	d.MessageArray(2, (import_0_.Schema{}).Idol__MessageType().Decode)
	d.MessageArray(3, (import_0_.UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_CodegenRequest__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (CodegenRequest, error) {
	if err := (_CodegenRequest__MessageType{}).Decode(ctx, buf); err != nil {
		return CodegenRequest{}, err
	}
	frozen := string(buf)
	return *(*CodegenRequest)(unsafe_.Pointer(&frozen)), nil
}

func (m CodegenRequest) Schema() import_0_.Schema {
	if v := m.msg.GetIndirect(1); len(v) > 0 {
		return *(*import_0_.Schema)(unsafe_.Pointer(&v))
	}
	return import_0_.Schema{}
}

func (m CodegenRequest) Dependencies() idol.MessageArray[import_0_.Schema] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[import_0_.Schema])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[import_0_.Schema]{}
}

func (m CodegenRequest) PluginOptions() idol.MessageArray[import_0_.UninterpretedOptions] {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*idol.MessageArray[import_0_.UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[import_0_.UninterpretedOptions]{}
}

type CodegenRequest__Builder struct {
	Schema        idol.MessageFieldBuilder[import_0_.Schema]
	Dependencies  idol.MessageArrayFieldBuilder[import_0_.Schema]
	PluginOptions idol.MessageArrayFieldBuilder[import_0_.UninterpretedOptions]
}

type _CodegenRequest__Builder struct {
	idol.IsGeneratedMessageBuilder[CodegenRequest]
	self *CodegenRequest__Builder
}

func (b *CodegenRequest__Builder) Idol__MessageBuilder() idol.MessageBuilder[CodegenRequest] {
	return _CodegenRequest__Builder{self: b}
}

func (m _CodegenRequest__Builder) Self() idol.AsMessageBuilder[CodegenRequest] { return m.self }

func (b _CodegenRequest__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _CodegenRequest__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Schema.IsPresent() {
		m.Indirect(1, b.self.Schema.DataSize())
	}
	if b.self.Dependencies.IsPresent() {
		m.Indirect(2, b.self.Dependencies.DataSize())
	}
	if b.self.PluginOptions.IsPresent() {
		m.Indirect(3, b.self.PluginOptions.DataSize())
	}
	return m.Finish()
}

func (b _CodegenRequest__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.PluginOptions.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Dependencies.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Schema.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Schema.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Dependencies.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.PluginOptions.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type CodegenResponse struct{ msg idol.DecodedMessage }

type _CodegenResponse__Message struct {
	idol.IsGeneratedMessage[CodegenResponse]
	self CodegenResponse
}

type _CodegenResponse__MessageType struct {
	idol.IsGeneratedMessageType[CodegenResponse]
}

func (m CodegenResponse) Idol__Message() idol.Message[CodegenResponse] {
	return _CodegenResponse__Message{self: m}
}

func (CodegenResponse) Idol__MessageType() idol.MessageType[CodegenResponse] {
	return _CodegenResponse__MessageType{}
}

func (m _CodegenResponse__Message) Self() CodegenResponse { return m.self }

func (m _CodegenResponse__Message) Type() idol.MessageType[CodegenResponse] {
	return _CodegenResponse__MessageType{}
}

func (m _CodegenResponse__Message) Size() uint32 { return m.self.msg.Size() }

func (m _CodegenResponse__Message) Fields() idol.MessageFields {
	return _CodegenResponse__MessageFields{m.self}
}

func (m _CodegenResponse__Message) Clone() idol.MessageBuilder[CodegenResponse] {
	b := &CodegenResponse__Builder{}
	b.OutputFiles.Extend(m.self.OutputFiles())
	b.Error.Set(m.self.Error())
	return b.Idol__MessageBuilder()
}

type _CodegenResponse__MessageFields struct {
	self CodegenResponse
}

func (f _CodegenResponse__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "output_files"
	case 2:
		return "error"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _CodegenResponse__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _CodegenResponse__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.OutputFiles()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Error()) {
			return
		}
	}
}

func (_CodegenResponse__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(1, (OutputFile{}).Idol__MessageType().Decode)
	d.Text(2)
	return d.Finish()
}

func (_CodegenResponse__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (CodegenResponse, error) {
	if err := (_CodegenResponse__MessageType{}).Decode(ctx, buf); err != nil {
		return CodegenResponse{}, err
	}
	frozen := string(buf)
	return *(*CodegenResponse)(unsafe_.Pointer(&frozen)), nil
}

func (m CodegenResponse) OutputFiles() idol.MessageArray[OutputFile] {
	if v := m.msg.GetIndirect(1); len(v) > 0 {
		return *(*idol.MessageArray[OutputFile])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[OutputFile]{}
}

func (m CodegenResponse) Error() idol.Text { return m.msg.GetText(2) }

type CodegenResponse__Builder struct {
	OutputFiles idol.MessageArrayFieldBuilder[OutputFile]
	Error       idol.TextFieldBuilder
}

type _CodegenResponse__Builder struct {
	idol.IsGeneratedMessageBuilder[CodegenResponse]
	self *CodegenResponse__Builder
}

func (b *CodegenResponse__Builder) Idol__MessageBuilder() idol.MessageBuilder[CodegenResponse] {
	return _CodegenResponse__Builder{self: b}
}

func (m _CodegenResponse__Builder) Self() idol.AsMessageBuilder[CodegenResponse] { return m.self }

func (b _CodegenResponse__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _CodegenResponse__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.OutputFiles.IsPresent() {
		m.Indirect(1, b.self.OutputFiles.DataSize())
	}
	if b.self.Error.IsPresent() {
		m.Indirect(2, b.self.Error.DataSize())
	}
	return m.Finish()
}

func (b _CodegenResponse__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Error.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.OutputFiles.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.OutputFiles.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Error.EncodeData(w); err != nil {
		return err
	}
	return nil
}

type OutputFile struct{ msg idol.DecodedMessage }

type _OutputFile__Message struct {
	idol.IsGeneratedMessage[OutputFile]
	self OutputFile
}

type _OutputFile__MessageType struct {
	idol.IsGeneratedMessageType[OutputFile]
}

func (m OutputFile) Idol__Message() idol.Message[OutputFile] {
	return _OutputFile__Message{self: m}
}

func (OutputFile) Idol__MessageType() idol.MessageType[OutputFile] {
	return _OutputFile__MessageType{}
}

func (m _OutputFile__Message) Self() OutputFile { return m.self }

func (m _OutputFile__Message) Type() idol.MessageType[OutputFile] {
	return _OutputFile__MessageType{}
}

func (m _OutputFile__Message) Size() uint32 { return m.self.msg.Size() }

func (m _OutputFile__Message) Fields() idol.MessageFields {
	return _OutputFile__MessageFields{m.self}
}

func (m _OutputFile__Message) Clone() idol.MessageBuilder[OutputFile] {
	b := &OutputFile__Builder{}
	b.Path.Extend(m.self.Path())
	b.Content.Extend(m.self.Content())
	b.InsertionPoint.Set(m.self.InsertionPoint())
	return b.Idol__MessageBuilder()
}

type _OutputFile__MessageFields struct {
	self OutputFile
}

func (f _OutputFile__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "path"
	case 2:
		return "content"
	case 3:
		return "insertion_point"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _OutputFile__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _OutputFile__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Path()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Content()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.InsertionPoint()) {
			return
		}
	}
}

func (_OutputFile__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.TextArray(1)
	d.Uint8Array(2)
	d.Text(3)
	return d.Finish()
}

func (_OutputFile__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (OutputFile, error) {
	if err := (_OutputFile__MessageType{}).Decode(ctx, buf); err != nil {
		return OutputFile{}, err
	}
	frozen := string(buf)
	return *(*OutputFile)(unsafe_.Pointer(&frozen)), nil
}

func (m OutputFile) Path() idol.TextArray { return m.msg.GetTextArray(1) }

func (m OutputFile) Content() idol.Uint8Array { return m.msg.GetUint8Array(2) }

func (m OutputFile) InsertionPoint() idol.Text { return m.msg.GetText(3) }

type OutputFile__Builder struct {
	Path           idol.TextArrayFieldBuilder
	Content        idol.Uint8ArrayFieldBuilder
	InsertionPoint idol.TextFieldBuilder
}

type _OutputFile__Builder struct {
	idol.IsGeneratedMessageBuilder[OutputFile]
	self *OutputFile__Builder
}

func (b *OutputFile__Builder) Idol__MessageBuilder() idol.MessageBuilder[OutputFile] {
	return _OutputFile__Builder{self: b}
}

func (m _OutputFile__Builder) Self() idol.AsMessageBuilder[OutputFile] { return m.self }

func (b _OutputFile__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _OutputFile__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Path.IsPresent() {
		m.Indirect(1, b.self.Path.DataSize())
	}
	if b.self.Content.IsPresent() {
		m.Indirect(2, b.self.Content.DataSize())
	}
	if b.self.InsertionPoint.IsPresent() {
		m.Indirect(3, b.self.InsertionPoint.DataSize())
	}
	return m.Finish()
}

func (b _OutputFile__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.InsertionPoint.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Content.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Path.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Path.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Content.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.InsertionPoint.EncodeData(w); err != nil {
		return err
	}
	return nil
}
