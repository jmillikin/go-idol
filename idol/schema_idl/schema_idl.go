// Copyright (c) 2024 John Millikin <john@john-millikin.com>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
// OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// SPDX-License-Identifier: 0BSD

// Code generated by idol-codegen-go. DO NOT EDIT.
// source: idol/idl/schema.idol

package schema_idl

import (
	binary_ "encoding/binary"
	fmt_ "fmt"
	io_ "io"
	iter_ "iter"
	unsafe_ "unsafe"

	"go.idol-lang.org/idol"
)

type Type uint8

const (
	Type_UNKNOWN Type = 0
	Type_BOOL         = 1
	Type_U8           = 2
	Type_I8           = 3
	Type_U16          = 4
	Type_I16          = 5
	Type_U32          = 6
	Type_I32          = 7
	Type_U64          = 8
	Type_I64          = 9
	Type_F32          = 10
	Type_F64          = 11
	Type_HANDLE       = 12
	Type_TEXT         = 13
	Type_ASCIZ        = 14
	Type_STRUCT       = 15
	Type_MESSAGE      = 16
	Type_UNION        = 17
)

func (e Type) String() string {
	switch e {
	case Type_UNKNOWN:
		return "UNKNOWN"
	case Type_BOOL:
		return "BOOL"
	case Type_U8:
		return "U8"
	case Type_I8:
		return "I8"
	case Type_U16:
		return "U16"
	case Type_I16:
		return "I16"
	case Type_U32:
		return "U32"
	case Type_I32:
		return "I32"
	case Type_U64:
		return "U64"
	case Type_I64:
		return "I64"
	case Type_F32:
		return "F32"
	case Type_F64:
		return "F64"
	case Type_HANDLE:
		return "HANDLE"
	case Type_TEXT:
		return "TEXT"
	case Type_ASCIZ:
		return "ASCIZ"
	case Type_STRUCT:
		return "STRUCT"
	case Type_MESSAGE:
		return "MESSAGE"
	case Type_UNION:
		return "UNION"
	default:
		return fmt_.Sprintf("Type(%d)", uint8(e))
	}
}

type ExportType uint8

const (
	ExportType_UNKNOWN  ExportType = 0
	ExportType_CONST               = 1
	ExportType_ENUM                = 2
	ExportType_STRUCT              = 3
	ExportType_MESSAGE             = 4
	ExportType_UNION               = 5
	ExportType_PROTOCOL            = 6
)

func (e ExportType) String() string {
	switch e {
	case ExportType_UNKNOWN:
		return "UNKNOWN"
	case ExportType_CONST:
		return "CONST"
	case ExportType_ENUM:
		return "ENUM"
	case ExportType_STRUCT:
		return "STRUCT"
	case ExportType_MESSAGE:
		return "MESSAGE"
	case ExportType_UNION:
		return "UNION"
	case ExportType_PROTOCOL:
		return "PROTOCOL"
	default:
		return fmt_.Sprintf("ExportType(%d)", uint8(e))
	}
}

type Schema struct{ msg idol.DecodedMessage }

type _Schema__Message struct {
	idol.IsGeneratedMessage[Schema]
	self Schema
}

type _Schema__MessageType struct {
	idol.IsGeneratedMessageType[Schema]
}

func (m Schema) Idol__Message() idol.Message[Schema] {
	return _Schema__Message{self: m}
}

func (Schema) Idol__MessageType() idol.MessageType[Schema] {
	return _Schema__MessageType{}
}

func (m _Schema__Message) Self() Schema { return m.self }

func (m _Schema__Message) Type() idol.MessageType[Schema] {
	return _Schema__MessageType{}
}

func (m _Schema__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Schema__Message) Fields() idol.MessageFields {
	return _Schema__MessageFields{m.self}
}

func (m _Schema__Message) Clone() idol.MessageBuilder[Schema] {
	b := &Schema__Builder{}
	b.Namespace.Set(m.self.Namespace())
	b.SourcePath.Extend(m.self.SourcePath())
	b.Imports.Extend(m.self.Imports())
	b.Exports.Extend(m.self.Exports())
	if m.self.msg.Has(5) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	b.Consts.Extend(m.self.Consts())
	b.Enums.Extend(m.self.Enums())
	b.Structs.Extend(m.self.Structs())
	b.Messages.Extend(m.self.Messages())
	b.Unions.Extend(m.self.Unions())
	b.Protocols.Extend(m.self.Protocols())
	return b.Idol__MessageBuilder()
}

type _Schema__MessageFields struct {
	self Schema
}

func (f _Schema__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "namespace"
	case 2:
		return "source_path"
	case 3:
		return "imports"
	case 4:
		return "exports"
	case 5:
		return "options"
	case 6:
		return "consts"
	case 7:
		return "enums"
	case 8:
		return "structs"
	case 9:
		return "messages"
	case 10:
		return "unions"
	case 11:
		return "protocols"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Schema__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Schema__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Namespace()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.SourcePath()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Imports()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.Exports()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.Options()) {
			return
		}
		if f.Has(6) && !yield(6, f.self.Consts()) {
			return
		}
		if f.Has(7) && !yield(7, f.self.Enums()) {
			return
		}
		if f.Has(8) && !yield(8, f.self.Structs()) {
			return
		}
		if f.Has(9) && !yield(9, f.self.Messages()) {
			return
		}
		if f.Has(10) && !yield(10, f.self.Unions()) {
			return
		}
		if f.Has(11) && !yield(11, f.self.Protocols()) {
			return
		}
	}
}

func (_Schema__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.TextArray(2)
	d.MessageArray(3, (Import{}).Idol__MessageType().Decode)
	d.MessageArray(4, (Export{}).Idol__MessageType().Decode)
	d.Message(5, (SchemaOptions{}).Idol__MessageType().Decode)
	d.MessageArray(6, (Const{}).Idol__MessageType().Decode)
	d.MessageArray(7, (Enum{}).Idol__MessageType().Decode)
	d.MessageArray(8, (Struct{}).Idol__MessageType().Decode)
	d.MessageArray(9, (Message{}).Idol__MessageType().Decode)
	d.MessageArray(10, (Union{}).Idol__MessageType().Decode)
	d.MessageArray(11, (Protocol{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Schema__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Schema, error) {
	if err := (_Schema__MessageType{}).Decode(ctx, buf); err != nil {
		return Schema{}, err
	}
	frozen := string(buf)
	return *(*Schema)(unsafe_.Pointer(&frozen)), nil
}

func (m Schema) Namespace() idol.Text { return m.msg.GetText(1) }

func (m Schema) SourcePath() idol.TextArray { return m.msg.GetTextArray(2) }

func (m Schema) Imports() idol.MessageArray[Import] {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*idol.MessageArray[Import])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Import]{}
}

func (m Schema) Exports() idol.MessageArray[Export] {
	if v := m.msg.GetIndirect(4); len(v) > 0 {
		return *(*idol.MessageArray[Export])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Export]{}
}

func (m Schema) Options() SchemaOptions {
	if v := m.msg.GetIndirect(5); len(v) > 0 {
		return *(*SchemaOptions)(unsafe_.Pointer(&v))
	}
	return SchemaOptions{}
}

func (m Schema) Consts() idol.MessageArray[Const] {
	if v := m.msg.GetIndirect(6); len(v) > 0 {
		return *(*idol.MessageArray[Const])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Const]{}
}

func (m Schema) Enums() idol.MessageArray[Enum] {
	if v := m.msg.GetIndirect(7); len(v) > 0 {
		return *(*idol.MessageArray[Enum])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Enum]{}
}

func (m Schema) Structs() idol.MessageArray[Struct] {
	if v := m.msg.GetIndirect(8); len(v) > 0 {
		return *(*idol.MessageArray[Struct])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Struct]{}
}

func (m Schema) Messages() idol.MessageArray[Message] {
	if v := m.msg.GetIndirect(9); len(v) > 0 {
		return *(*idol.MessageArray[Message])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Message]{}
}

func (m Schema) Unions() idol.MessageArray[Union] {
	if v := m.msg.GetIndirect(10); len(v) > 0 {
		return *(*idol.MessageArray[Union])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Union]{}
}

func (m Schema) Protocols() idol.MessageArray[Protocol] {
	if v := m.msg.GetIndirect(11); len(v) > 0 {
		return *(*idol.MessageArray[Protocol])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[Protocol]{}
}

type Schema__Builder struct {
	Namespace  idol.TextFieldBuilder
	SourcePath idol.TextArrayFieldBuilder
	Imports    idol.MessageArrayFieldBuilder[Import]
	Exports    idol.MessageArrayFieldBuilder[Export]
	Options    idol.MessageFieldBuilder[SchemaOptions]
	Consts     idol.MessageArrayFieldBuilder[Const]
	Enums      idol.MessageArrayFieldBuilder[Enum]
	Structs    idol.MessageArrayFieldBuilder[Struct]
	Messages   idol.MessageArrayFieldBuilder[Message]
	Unions     idol.MessageArrayFieldBuilder[Union]
	Protocols  idol.MessageArrayFieldBuilder[Protocol]
}

type _Schema__Builder struct {
	idol.IsGeneratedMessageBuilder[Schema]
	self *Schema__Builder
}

func (b *Schema__Builder) Idol__MessageBuilder() idol.MessageBuilder[Schema] {
	return _Schema__Builder{self: b}
}

func (m _Schema__Builder) Self() idol.AsMessageBuilder[Schema] { return m.self }

func (b _Schema__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Schema__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Namespace.IsPresent() {
		m.Indirect(1, b.self.Namespace.DataSize())
	}
	if b.self.SourcePath.IsPresent() {
		m.Indirect(2, b.self.SourcePath.DataSize())
	}
	if b.self.Imports.IsPresent() {
		m.Indirect(3, b.self.Imports.DataSize())
	}
	if b.self.Exports.IsPresent() {
		m.Indirect(4, b.self.Exports.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(5, b.self.Options.DataSize())
	}
	if b.self.Consts.IsPresent() {
		m.Indirect(6, b.self.Consts.DataSize())
	}
	if b.self.Enums.IsPresent() {
		m.Indirect(7, b.self.Enums.DataSize())
	}
	if b.self.Structs.IsPresent() {
		m.Indirect(8, b.self.Structs.DataSize())
	}
	if b.self.Messages.IsPresent() {
		m.Indirect(9, b.self.Messages.DataSize())
	}
	if b.self.Unions.IsPresent() {
		m.Indirect(10, b.self.Unions.DataSize())
	}
	if b.self.Protocols.IsPresent() {
		m.Indirect(11, b.self.Protocols.DataSize())
	}
	return m.Finish()
}

func (b _Schema__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [96]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 11:
		b.self.Protocols.PutThunk(ht[88:96])
		fallthrough
	case 10:
		b.self.Unions.PutThunk(ht[80:88])
		fallthrough
	case 9:
		b.self.Messages.PutThunk(ht[72:80])
		fallthrough
	case 8:
		b.self.Structs.PutThunk(ht[64:72])
		fallthrough
	case 7:
		b.self.Enums.PutThunk(ht[56:64])
		fallthrough
	case 6:
		b.self.Consts.PutThunk(ht[48:56])
		fallthrough
	case 5:
		b.self.Options.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.Exports.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.Imports.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.SourcePath.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Namespace.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Namespace.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.SourcePath.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Imports.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Exports.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Consts.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Enums.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Structs.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Messages.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Unions.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Protocols.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type Import struct{ msg idol.DecodedMessage }

type _Import__Message struct {
	idol.IsGeneratedMessage[Import]
	self Import
}

type _Import__MessageType struct {
	idol.IsGeneratedMessageType[Import]
}

func (m Import) Idol__Message() idol.Message[Import] {
	return _Import__Message{self: m}
}

func (Import) Idol__MessageType() idol.MessageType[Import] {
	return _Import__MessageType{}
}

func (m _Import__Message) Self() Import { return m.self }

func (m _Import__Message) Type() idol.MessageType[Import] {
	return _Import__MessageType{}
}

func (m _Import__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Import__Message) Fields() idol.MessageFields {
	return _Import__MessageFields{m.self}
}

func (m _Import__Message) Clone() idol.MessageBuilder[Import] {
	b := &Import__Builder{}
	b.Namespace.Set(m.self.Namespace())
	b.Names.Extend(m.self.Names())
	return b.Idol__MessageBuilder()
}

type _Import__MessageFields struct {
	self Import
}

func (f _Import__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "namespace"
	case 2:
		return "names"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Import__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Import__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Namespace()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Names()) {
			return
		}
	}
}

func (_Import__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.TextArray(2)
	return d.Finish()
}

func (_Import__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Import, error) {
	if err := (_Import__MessageType{}).Decode(ctx, buf); err != nil {
		return Import{}, err
	}
	frozen := string(buf)
	return *(*Import)(unsafe_.Pointer(&frozen)), nil
}

func (m Import) Namespace() idol.Text { return m.msg.GetText(1) }

func (m Import) Names() idol.TextArray { return m.msg.GetTextArray(2) }

type Import__Builder struct {
	Namespace idol.TextFieldBuilder
	Names     idol.TextArrayFieldBuilder
}

type _Import__Builder struct {
	idol.IsGeneratedMessageBuilder[Import]
	self *Import__Builder
}

func (b *Import__Builder) Idol__MessageBuilder() idol.MessageBuilder[Import] {
	return _Import__Builder{self: b}
}

func (m _Import__Builder) Self() idol.AsMessageBuilder[Import] { return m.self }

func (b _Import__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Import__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Namespace.IsPresent() {
		m.Indirect(1, b.self.Namespace.DataSize())
	}
	if b.self.Names.IsPresent() {
		m.Indirect(2, b.self.Names.DataSize())
	}
	return m.Finish()
}

func (b _Import__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Names.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Namespace.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Namespace.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Names.EncodeData(w); err != nil {
		return err
	}
	return nil
}

type Export struct{ msg idol.DecodedMessage }

type _Export__Message struct {
	idol.IsGeneratedMessage[Export]
	self Export
}

type _Export__MessageType struct {
	idol.IsGeneratedMessageType[Export]
}

func (m Export) Idol__Message() idol.Message[Export] {
	return _Export__Message{self: m}
}

func (Export) Idol__MessageType() idol.MessageType[Export] {
	return _Export__MessageType{}
}

func (m _Export__Message) Self() Export { return m.self }

func (m _Export__Message) Type() idol.MessageType[Export] {
	return _Export__MessageType{}
}

func (m _Export__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Export__Message) Fields() idol.MessageFields {
	return _Export__MessageFields{m.self}
}

func (m _Export__Message) Clone() idol.MessageBuilder[Export] {
	b := &Export__Builder{}
	b.Type.Set(m.self.Type())
	b.TypeName.Set(m.self.TypeName())
	b.ExportAs.Set(m.self.ExportAs())
	return b.Idol__MessageBuilder()
}

type _Export__MessageFields struct {
	self Export
}

func (f _Export__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "type"
	case 2:
		return "type_name"
	case 3:
		return "export_as"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Export__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Export__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Type()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.TypeName()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.ExportAs()) {
			return
		}
	}
}

func (_Export__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Uint8(1)
	d.Text(2)
	d.Text(3)
	return d.Finish()
}

func (_Export__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Export, error) {
	if err := (_Export__MessageType{}).Decode(ctx, buf); err != nil {
		return Export{}, err
	}
	frozen := string(buf)
	return *(*Export)(unsafe_.Pointer(&frozen)), nil
}

func (m Export) Type() ExportType { return ExportType(m.msg.GetUint32(1)) }

func (m Export) TypeName() idol.Text { return m.msg.GetText(2) }

func (m Export) ExportAs() idol.Text { return m.msg.GetText(3) }

type Export__Builder struct {
	Type     idol.EnumFieldBuilder[ExportType]
	TypeName idol.TextFieldBuilder
	ExportAs idol.TextFieldBuilder
}

type _Export__Builder struct {
	idol.IsGeneratedMessageBuilder[Export]
	self *Export__Builder
}

func (b *Export__Builder) Idol__MessageBuilder() idol.MessageBuilder[Export] {
	return _Export__Builder{self: b}
}

func (m _Export__Builder) Self() idol.AsMessageBuilder[Export] { return m.self }

func (b _Export__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Export__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Type.IsPresent() {
		m.Scalar(1)
	}
	if b.self.TypeName.IsPresent() {
		m.Indirect(2, b.self.TypeName.DataSize())
	}
	if b.self.ExportAs.IsPresent() {
		m.Indirect(3, b.self.ExportAs.DataSize())
	}
	return m.Finish()
}

func (b _Export__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.ExportAs.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.TypeName.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Type.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.TypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.ExportAs.EncodeData(w); err != nil {
		return err
	}
	return nil
}

type Const struct{ msg idol.DecodedMessage }

type _Const__Message struct {
	idol.IsGeneratedMessage[Const]
	self Const
}

type _Const__MessageType struct {
	idol.IsGeneratedMessageType[Const]
}

func (m Const) Idol__Message() idol.Message[Const] {
	return _Const__Message{self: m}
}

func (Const) Idol__MessageType() idol.MessageType[Const] {
	return _Const__MessageType{}
}

func (m _Const__Message) Self() Const { return m.self }

func (m _Const__Message) Type() idol.MessageType[Const] {
	return _Const__MessageType{}
}

func (m _Const__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Const__Message) Fields() idol.MessageFields {
	return _Const__MessageFields{m.self}
}

func (m _Const__Message) Clone() idol.MessageBuilder[Const] {
	b := &Const__Builder{}
	b.Name.Set(m.self.Name())
	b.Type.Set(m.self.Type())
	b.TypeName.Set(m.self.TypeName())
	b.Value.Extend(m.self.Value())
	if m.self.msg.Has(5) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _Const__MessageFields struct {
	self Const
}

func (f _Const__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "type"
	case 3:
		return "type_name"
	case 4:
		return "value"
	case 5:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Const__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Const__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Type()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.TypeName()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.Value()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.Options()) {
			return
		}
	}
}

func (_Const__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint8(2)
	d.Text(3)
	d.Uint8Array(4)
	d.Message(5, (ConstOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Const__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Const, error) {
	if err := (_Const__MessageType{}).Decode(ctx, buf); err != nil {
		return Const{}, err
	}
	frozen := string(buf)
	return *(*Const)(unsafe_.Pointer(&frozen)), nil
}

func (m Const) Name() idol.Text { return m.msg.GetText(1) }

func (m Const) Type() Type { return Type(m.msg.GetUint32(2)) }

func (m Const) TypeName() idol.Text { return m.msg.GetText(3) }

func (m Const) Value() idol.Uint8Array { return m.msg.GetUint8Array(4) }

func (m Const) Options() ConstOptions {
	if v := m.msg.GetIndirect(5); len(v) > 0 {
		return *(*ConstOptions)(unsafe_.Pointer(&v))
	}
	return ConstOptions{}
}

type Const__Builder struct {
	Name     idol.TextFieldBuilder
	Type     idol.EnumFieldBuilder[Type]
	TypeName idol.TextFieldBuilder
	Value    idol.Uint8ArrayFieldBuilder
	Options  idol.MessageFieldBuilder[ConstOptions]
}

type _Const__Builder struct {
	idol.IsGeneratedMessageBuilder[Const]
	self *Const__Builder
}

func (b *Const__Builder) Idol__MessageBuilder() idol.MessageBuilder[Const] {
	return _Const__Builder{self: b}
}

func (m _Const__Builder) Self() idol.AsMessageBuilder[Const] { return m.self }

func (b _Const__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Const__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Type.IsPresent() {
		m.Scalar(2)
	}
	if b.self.TypeName.IsPresent() {
		m.Indirect(3, b.self.TypeName.DataSize())
	}
	if b.self.Value.IsPresent() {
		m.Indirect(4, b.self.Value.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(5, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _Const__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [48]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 5:
		b.self.Options.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.Value.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.TypeName.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Type.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.TypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Value.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type Enum struct{ msg idol.DecodedMessage }

type _Enum__Message struct {
	idol.IsGeneratedMessage[Enum]
	self Enum
}

type _Enum__MessageType struct {
	idol.IsGeneratedMessageType[Enum]
}

func (m Enum) Idol__Message() idol.Message[Enum] {
	return _Enum__Message{self: m}
}

func (Enum) Idol__MessageType() idol.MessageType[Enum] {
	return _Enum__MessageType{}
}

func (m _Enum__Message) Self() Enum { return m.self }

func (m _Enum__Message) Type() idol.MessageType[Enum] {
	return _Enum__MessageType{}
}

func (m _Enum__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Enum__Message) Fields() idol.MessageFields {
	return _Enum__MessageFields{m.self}
}

func (m _Enum__Message) Clone() idol.MessageBuilder[Enum] {
	b := &Enum__Builder{}
	b.Name.Set(m.self.Name())
	b.Type.Set(m.self.Type())
	if m.self.msg.Has(4) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	b.Items.Extend(m.self.Items())
	return b.Idol__MessageBuilder()
}

type _Enum__MessageFields struct {
	self Enum
}

func (f _Enum__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "type"
	case 3:
		return "items"
	case 4:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Enum__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Enum__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Type()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.Options()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Items()) {
			return
		}
	}
}

func (_Enum__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint8(2)
	d.MessageArray(3, (EnumItem{}).Idol__MessageType().Decode)
	d.Message(4, (EnumOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Enum__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Enum, error) {
	if err := (_Enum__MessageType{}).Decode(ctx, buf); err != nil {
		return Enum{}, err
	}
	frozen := string(buf)
	return *(*Enum)(unsafe_.Pointer(&frozen)), nil
}

func (m Enum) Name() idol.Text { return m.msg.GetText(1) }

func (m Enum) Type() Type { return Type(m.msg.GetUint32(2)) }

func (m Enum) Options() EnumOptions {
	if v := m.msg.GetIndirect(4); len(v) > 0 {
		return *(*EnumOptions)(unsafe_.Pointer(&v))
	}
	return EnumOptions{}
}

func (m Enum) Items() idol.MessageArray[EnumItem] {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*idol.MessageArray[EnumItem])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[EnumItem]{}
}

type Enum__Builder struct {
	Name    idol.TextFieldBuilder
	Type    idol.EnumFieldBuilder[Type]
	Options idol.MessageFieldBuilder[EnumOptions]
	Items   idol.MessageArrayFieldBuilder[EnumItem]
}

type _Enum__Builder struct {
	idol.IsGeneratedMessageBuilder[Enum]
	self *Enum__Builder
}

func (b *Enum__Builder) Idol__MessageBuilder() idol.MessageBuilder[Enum] {
	return _Enum__Builder{self: b}
}

func (m _Enum__Builder) Self() idol.AsMessageBuilder[Enum] { return m.self }

func (b _Enum__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Enum__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Type.IsPresent() {
		m.Scalar(2)
	}
	if b.self.Items.IsPresent() {
		m.Indirect(3, b.self.Items.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(4, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _Enum__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [40]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 4:
		b.self.Options.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.Items.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Type.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Items.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type EnumItem struct{ msg idol.DecodedMessage }

type _EnumItem__Message struct {
	idol.IsGeneratedMessage[EnumItem]
	self EnumItem
}

type _EnumItem__MessageType struct {
	idol.IsGeneratedMessageType[EnumItem]
}

func (m EnumItem) Idol__Message() idol.Message[EnumItem] {
	return _EnumItem__Message{self: m}
}

func (EnumItem) Idol__MessageType() idol.MessageType[EnumItem] {
	return _EnumItem__MessageType{}
}

func (m _EnumItem__Message) Self() EnumItem { return m.self }

func (m _EnumItem__Message) Type() idol.MessageType[EnumItem] {
	return _EnumItem__MessageType{}
}

func (m _EnumItem__Message) Size() uint32 { return m.self.msg.Size() }

func (m _EnumItem__Message) Fields() idol.MessageFields {
	return _EnumItem__MessageFields{m.self}
}

func (m _EnumItem__Message) Clone() idol.MessageBuilder[EnumItem] {
	b := &EnumItem__Builder{}
	b.Name.Set(m.self.Name())
	b.Value.Set(m.self.Value())
	b.IsAlias.Set(m.self.IsAlias())
	if m.self.msg.Has(4) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _EnumItem__MessageFields struct {
	self EnumItem
}

func (f _EnumItem__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "value"
	case 3:
		return "is_alias"
	case 4:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _EnumItem__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _EnumItem__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Value()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.IsAlias()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.Options()) {
			return
		}
	}
}

func (_EnumItem__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint64(2)
	d.Bool(3)
	d.Message(4, (EnumItemOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_EnumItem__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (EnumItem, error) {
	if err := (_EnumItem__MessageType{}).Decode(ctx, buf); err != nil {
		return EnumItem{}, err
	}
	frozen := string(buf)
	return *(*EnumItem)(unsafe_.Pointer(&frozen)), nil
}

func (m EnumItem) Name() idol.Text { return m.msg.GetText(1) }

func (m EnumItem) Value() uint64 { return m.msg.GetUint64(2) }

func (m EnumItem) IsAlias() bool { return m.msg.GetBool(3) }

func (m EnumItem) Options() EnumItemOptions {
	if v := m.msg.GetIndirect(4); len(v) > 0 {
		return *(*EnumItemOptions)(unsafe_.Pointer(&v))
	}
	return EnumItemOptions{}
}

type EnumItem__Builder struct {
	Name    idol.TextFieldBuilder
	Value   idol.Uint64FieldBuilder
	IsAlias idol.BoolFieldBuilder
	Options idol.MessageFieldBuilder[EnumItemOptions]
}

type _EnumItem__Builder struct {
	idol.IsGeneratedMessageBuilder[EnumItem]
	self *EnumItem__Builder
}

func (b *EnumItem__Builder) Idol__MessageBuilder() idol.MessageBuilder[EnumItem] {
	return _EnumItem__Builder{self: b}
}

func (m _EnumItem__Builder) Self() idol.AsMessageBuilder[EnumItem] { return m.self }

func (b _EnumItem__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _EnumItem__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Value.IsPresent() {
		m.Indirect(2, b.self.Value.DataSize())
	}
	if b.self.IsAlias.IsPresent() {
		m.Scalar(3)
	}
	if b.self.Options.IsPresent() {
		m.Indirect(4, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _EnumItem__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [40]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 4:
		b.self.Options.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.IsAlias.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Value.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Value.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type Struct struct{ msg idol.DecodedMessage }

type _Struct__Message struct {
	idol.IsGeneratedMessage[Struct]
	self Struct
}

type _Struct__MessageType struct {
	idol.IsGeneratedMessageType[Struct]
}

func (m Struct) Idol__Message() idol.Message[Struct] {
	return _Struct__Message{self: m}
}

func (Struct) Idol__MessageType() idol.MessageType[Struct] {
	return _Struct__MessageType{}
}

func (m _Struct__Message) Self() Struct { return m.self }

func (m _Struct__Message) Type() idol.MessageType[Struct] {
	return _Struct__MessageType{}
}

func (m _Struct__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Struct__Message) Fields() idol.MessageFields {
	return _Struct__MessageFields{m.self}
}

func (m _Struct__Message) Clone() idol.MessageBuilder[Struct] {
	b := &Struct__Builder{}
	b.Name.Set(m.self.Name())
	if m.self.msg.Has(3) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	b.Fields.Extend(m.self.Fields())
	return b.Idol__MessageBuilder()
}

type _Struct__MessageFields struct {
	self Struct
}

func (f _Struct__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "fields"
	case 3:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Struct__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Struct__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Options()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Fields()) {
			return
		}
	}
}

func (_Struct__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.MessageArray(2, (StructField{}).Idol__MessageType().Decode)
	d.Message(3, (StructOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Struct__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Struct, error) {
	if err := (_Struct__MessageType{}).Decode(ctx, buf); err != nil {
		return Struct{}, err
	}
	frozen := string(buf)
	return *(*Struct)(unsafe_.Pointer(&frozen)), nil
}

func (m Struct) Name() idol.Text { return m.msg.GetText(1) }

func (m Struct) Options() StructOptions {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*StructOptions)(unsafe_.Pointer(&v))
	}
	return StructOptions{}
}

func (m Struct) Fields() idol.MessageArray[StructField] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[StructField])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[StructField]{}
}

type Struct__Builder struct {
	Name    idol.TextFieldBuilder
	Options idol.MessageFieldBuilder[StructOptions]
	Fields  idol.MessageArrayFieldBuilder[StructField]
}

type _Struct__Builder struct {
	idol.IsGeneratedMessageBuilder[Struct]
	self *Struct__Builder
}

func (b *Struct__Builder) Idol__MessageBuilder() idol.MessageBuilder[Struct] {
	return _Struct__Builder{self: b}
}

func (m _Struct__Builder) Self() idol.AsMessageBuilder[Struct] { return m.self }

func (b _Struct__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Struct__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Fields.IsPresent() {
		m.Indirect(2, b.self.Fields.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(3, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _Struct__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.Options.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Fields.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Fields.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type StructField struct{ msg idol.DecodedMessage }

type _StructField__Message struct {
	idol.IsGeneratedMessage[StructField]
	self StructField
}

type _StructField__MessageType struct {
	idol.IsGeneratedMessageType[StructField]
}

func (m StructField) Idol__Message() idol.Message[StructField] {
	return _StructField__Message{self: m}
}

func (StructField) Idol__MessageType() idol.MessageType[StructField] {
	return _StructField__MessageType{}
}

func (m _StructField__Message) Self() StructField { return m.self }

func (m _StructField__Message) Type() idol.MessageType[StructField] {
	return _StructField__MessageType{}
}

func (m _StructField__Message) Size() uint32 { return m.self.msg.Size() }

func (m _StructField__Message) Fields() idol.MessageFields {
	return _StructField__MessageFields{m.self}
}

func (m _StructField__Message) Clone() idol.MessageBuilder[StructField] {
	b := &StructField__Builder{}
	b.Name.Set(m.self.Name())
	b.Type.Set(m.self.Type())
	b.TypeName.Set(m.self.TypeName())
	b.ArrayLen.Set(m.self.ArrayLen())
	if m.self.msg.Has(5) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _StructField__MessageFields struct {
	self StructField
}

func (f _StructField__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "type"
	case 3:
		return "type_name"
	case 4:
		return "array_len"
	case 5:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _StructField__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _StructField__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Type()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.TypeName()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.ArrayLen()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.Options()) {
			return
		}
	}
}

func (_StructField__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint8(2)
	d.Text(3)
	d.Uint32(4)
	d.Message(5, (StructFieldOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_StructField__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (StructField, error) {
	if err := (_StructField__MessageType{}).Decode(ctx, buf); err != nil {
		return StructField{}, err
	}
	frozen := string(buf)
	return *(*StructField)(unsafe_.Pointer(&frozen)), nil
}

func (m StructField) Name() idol.Text { return m.msg.GetText(1) }

func (m StructField) Type() Type { return Type(m.msg.GetUint32(2)) }

func (m StructField) TypeName() idol.Text { return m.msg.GetText(3) }

func (m StructField) ArrayLen() uint32 { return m.msg.GetUint32(4) }

func (m StructField) Options() StructFieldOptions {
	if v := m.msg.GetIndirect(5); len(v) > 0 {
		return *(*StructFieldOptions)(unsafe_.Pointer(&v))
	}
	return StructFieldOptions{}
}

type StructField__Builder struct {
	Name     idol.TextFieldBuilder
	Type     idol.EnumFieldBuilder[Type]
	TypeName idol.TextFieldBuilder
	ArrayLen idol.Uint32FieldBuilder
	Options  idol.MessageFieldBuilder[StructFieldOptions]
}

type _StructField__Builder struct {
	idol.IsGeneratedMessageBuilder[StructField]
	self *StructField__Builder
}

func (b *StructField__Builder) Idol__MessageBuilder() idol.MessageBuilder[StructField] {
	return _StructField__Builder{self: b}
}

func (m _StructField__Builder) Self() idol.AsMessageBuilder[StructField] { return m.self }

func (b _StructField__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _StructField__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Type.IsPresent() {
		m.Scalar(2)
	}
	if b.self.TypeName.IsPresent() {
		m.Indirect(3, b.self.TypeName.DataSize())
	}
	if b.self.ArrayLen.IsPresent() {
		m.Scalar(4)
	}
	if b.self.Options.IsPresent() {
		m.Indirect(5, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _StructField__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [48]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 5:
		b.self.Options.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.ArrayLen.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.TypeName.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Type.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.TypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type Message struct{ msg idol.DecodedMessage }

type _Message__Message struct {
	idol.IsGeneratedMessage[Message]
	self Message
}

type _Message__MessageType struct {
	idol.IsGeneratedMessageType[Message]
}

func (m Message) Idol__Message() idol.Message[Message] {
	return _Message__Message{self: m}
}

func (Message) Idol__MessageType() idol.MessageType[Message] {
	return _Message__MessageType{}
}

func (m _Message__Message) Self() Message { return m.self }

func (m _Message__Message) Type() idol.MessageType[Message] {
	return _Message__MessageType{}
}

func (m _Message__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Message__Message) Fields() idol.MessageFields {
	return _Message__MessageFields{m.self}
}

func (m _Message__Message) Clone() idol.MessageBuilder[Message] {
	b := &Message__Builder{}
	b.Name.Set(m.self.Name())
	if m.self.msg.Has(3) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	b.Fields.Extend(m.self.Fields())
	return b.Idol__MessageBuilder()
}

type _Message__MessageFields struct {
	self Message
}

func (f _Message__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "fields"
	case 3:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Message__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Message__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Options()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Fields()) {
			return
		}
	}
}

func (_Message__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.MessageArray(2, (MessageField{}).Idol__MessageType().Decode)
	d.Message(3, (MessageOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Message__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Message, error) {
	if err := (_Message__MessageType{}).Decode(ctx, buf); err != nil {
		return Message{}, err
	}
	frozen := string(buf)
	return *(*Message)(unsafe_.Pointer(&frozen)), nil
}

func (m Message) Name() idol.Text { return m.msg.GetText(1) }

func (m Message) Options() MessageOptions {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*MessageOptions)(unsafe_.Pointer(&v))
	}
	return MessageOptions{}
}

func (m Message) Fields() idol.MessageArray[MessageField] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[MessageField])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[MessageField]{}
}

type Message__Builder struct {
	Name    idol.TextFieldBuilder
	Options idol.MessageFieldBuilder[MessageOptions]
	Fields  idol.MessageArrayFieldBuilder[MessageField]
}

type _Message__Builder struct {
	idol.IsGeneratedMessageBuilder[Message]
	self *Message__Builder
}

func (b *Message__Builder) Idol__MessageBuilder() idol.MessageBuilder[Message] {
	return _Message__Builder{self: b}
}

func (m _Message__Builder) Self() idol.AsMessageBuilder[Message] { return m.self }

func (b _Message__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Message__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Fields.IsPresent() {
		m.Indirect(2, b.self.Fields.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(3, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _Message__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.Options.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Fields.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Fields.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type MessageField struct{ msg idol.DecodedMessage }

type _MessageField__Message struct {
	idol.IsGeneratedMessage[MessageField]
	self MessageField
}

type _MessageField__MessageType struct {
	idol.IsGeneratedMessageType[MessageField]
}

func (m MessageField) Idol__Message() idol.Message[MessageField] {
	return _MessageField__Message{self: m}
}

func (MessageField) Idol__MessageType() idol.MessageType[MessageField] {
	return _MessageField__MessageType{}
}

func (m _MessageField__Message) Self() MessageField { return m.self }

func (m _MessageField__Message) Type() idol.MessageType[MessageField] {
	return _MessageField__MessageType{}
}

func (m _MessageField__Message) Size() uint32 { return m.self.msg.Size() }

func (m _MessageField__Message) Fields() idol.MessageFields {
	return _MessageField__MessageFields{m.self}
}

func (m _MessageField__Message) Clone() idol.MessageBuilder[MessageField] {
	b := &MessageField__Builder{}
	b.Name.Set(m.self.Name())
	b.Tag.Set(m.self.Tag())
	b.Type.Set(m.self.Type())
	b.TypeName.Set(m.self.TypeName())
	b.ArrayLen.Set(m.self.ArrayLen())
	if m.self.msg.Has(6) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _MessageField__MessageFields struct {
	self MessageField
}

func (f _MessageField__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "tag"
	case 3:
		return "type"
	case 4:
		return "type_name"
	case 5:
		return "array_len"
	case 6:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _MessageField__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _MessageField__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Tag()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Type()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.TypeName()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.ArrayLen()) {
			return
		}
		if f.Has(6) && !yield(6, f.self.Options()) {
			return
		}
	}
}

func (_MessageField__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint16(2)
	d.Uint8(3)
	d.Text(4)
	d.Uint32(5)
	d.Message(6, (MessageFieldOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_MessageField__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (MessageField, error) {
	if err := (_MessageField__MessageType{}).Decode(ctx, buf); err != nil {
		return MessageField{}, err
	}
	frozen := string(buf)
	return *(*MessageField)(unsafe_.Pointer(&frozen)), nil
}

func (m MessageField) Name() idol.Text { return m.msg.GetText(1) }

func (m MessageField) Tag() uint16 { return uint16(m.msg.GetUint32(2)) }

func (m MessageField) Type() Type { return Type(m.msg.GetUint32(3)) }

func (m MessageField) TypeName() idol.Text { return m.msg.GetText(4) }

func (m MessageField) ArrayLen() uint32 { return m.msg.GetUint32(5) }

func (m MessageField) Options() MessageFieldOptions {
	if v := m.msg.GetIndirect(6); len(v) > 0 {
		return *(*MessageFieldOptions)(unsafe_.Pointer(&v))
	}
	return MessageFieldOptions{}
}

type MessageField__Builder struct {
	Name     idol.TextFieldBuilder
	Tag      idol.Uint16FieldBuilder
	Type     idol.EnumFieldBuilder[Type]
	TypeName idol.TextFieldBuilder
	ArrayLen idol.Uint32FieldBuilder
	Options  idol.MessageFieldBuilder[MessageFieldOptions]
}

type _MessageField__Builder struct {
	idol.IsGeneratedMessageBuilder[MessageField]
	self *MessageField__Builder
}

func (b *MessageField__Builder) Idol__MessageBuilder() idol.MessageBuilder[MessageField] {
	return _MessageField__Builder{self: b}
}

func (m _MessageField__Builder) Self() idol.AsMessageBuilder[MessageField] { return m.self }

func (b _MessageField__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _MessageField__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Tag.IsPresent() {
		m.Scalar(2)
	}
	if b.self.Type.IsPresent() {
		m.Scalar(3)
	}
	if b.self.TypeName.IsPresent() {
		m.Indirect(4, b.self.TypeName.DataSize())
	}
	if b.self.ArrayLen.IsPresent() {
		m.Scalar(5)
	}
	if b.self.Options.IsPresent() {
		m.Indirect(6, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _MessageField__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [56]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 6:
		b.self.Options.PutThunk(ht[48:56])
		fallthrough
	case 5:
		b.self.ArrayLen.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.TypeName.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.Type.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Tag.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.TypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type Union struct{ msg idol.DecodedMessage }

type _Union__Message struct {
	idol.IsGeneratedMessage[Union]
	self Union
}

type _Union__MessageType struct {
	idol.IsGeneratedMessageType[Union]
}

func (m Union) Idol__Message() idol.Message[Union] {
	return _Union__Message{self: m}
}

func (Union) Idol__MessageType() idol.MessageType[Union] {
	return _Union__MessageType{}
}

func (m _Union__Message) Self() Union { return m.self }

func (m _Union__Message) Type() idol.MessageType[Union] {
	return _Union__MessageType{}
}

func (m _Union__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Union__Message) Fields() idol.MessageFields {
	return _Union__MessageFields{m.self}
}

func (m _Union__Message) Clone() idol.MessageBuilder[Union] {
	b := &Union__Builder{}
	b.Name.Set(m.self.Name())
	if m.self.msg.Has(3) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	b.Fields.Extend(m.self.Fields())
	return b.Idol__MessageBuilder()
}

type _Union__MessageFields struct {
	self Union
}

func (f _Union__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "fields"
	case 3:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Union__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Union__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Options()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Fields()) {
			return
		}
	}
}

func (_Union__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.MessageArray(2, (UnionField{}).Idol__MessageType().Decode)
	d.Message(3, (UnionOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Union__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Union, error) {
	if err := (_Union__MessageType{}).Decode(ctx, buf); err != nil {
		return Union{}, err
	}
	frozen := string(buf)
	return *(*Union)(unsafe_.Pointer(&frozen)), nil
}

func (m Union) Name() idol.Text { return m.msg.GetText(1) }

func (m Union) Options() UnionOptions {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*UnionOptions)(unsafe_.Pointer(&v))
	}
	return UnionOptions{}
}

func (m Union) Fields() idol.MessageArray[UnionField] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UnionField])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UnionField]{}
}

type Union__Builder struct {
	Name    idol.TextFieldBuilder
	Options idol.MessageFieldBuilder[UnionOptions]
	Fields  idol.MessageArrayFieldBuilder[UnionField]
}

type _Union__Builder struct {
	idol.IsGeneratedMessageBuilder[Union]
	self *Union__Builder
}

func (b *Union__Builder) Idol__MessageBuilder() idol.MessageBuilder[Union] {
	return _Union__Builder{self: b}
}

func (m _Union__Builder) Self() idol.AsMessageBuilder[Union] { return m.self }

func (b _Union__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Union__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Fields.IsPresent() {
		m.Indirect(2, b.self.Fields.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(3, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _Union__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.Options.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Fields.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Fields.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type UnionField struct{ msg idol.DecodedMessage }

type _UnionField__Message struct {
	idol.IsGeneratedMessage[UnionField]
	self UnionField
}

type _UnionField__MessageType struct {
	idol.IsGeneratedMessageType[UnionField]
}

func (m UnionField) Idol__Message() idol.Message[UnionField] {
	return _UnionField__Message{self: m}
}

func (UnionField) Idol__MessageType() idol.MessageType[UnionField] {
	return _UnionField__MessageType{}
}

func (m _UnionField__Message) Self() UnionField { return m.self }

func (m _UnionField__Message) Type() idol.MessageType[UnionField] {
	return _UnionField__MessageType{}
}

func (m _UnionField__Message) Size() uint32 { return m.self.msg.Size() }

func (m _UnionField__Message) Fields() idol.MessageFields {
	return _UnionField__MessageFields{m.self}
}

func (m _UnionField__Message) Clone() idol.MessageBuilder[UnionField] {
	b := &UnionField__Builder{}
	b.Name.Set(m.self.Name())
	b.Tag.Set(m.self.Tag())
	b.Type.Set(m.self.Type())
	b.TypeName.Set(m.self.TypeName())
	b.ArrayLen.Set(m.self.ArrayLen())
	if m.self.msg.Has(6) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _UnionField__MessageFields struct {
	self UnionField
}

func (f _UnionField__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "tag"
	case 3:
		return "type"
	case 4:
		return "type_name"
	case 5:
		return "array_len"
	case 6:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _UnionField__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _UnionField__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Tag()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Type()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.TypeName()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.ArrayLen()) {
			return
		}
		if f.Has(6) && !yield(6, f.self.Options()) {
			return
		}
	}
}

func (_UnionField__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint16(2)
	d.Uint8(3)
	d.Text(4)
	d.Uint32(5)
	d.Message(6, (UnionFieldOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_UnionField__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (UnionField, error) {
	if err := (_UnionField__MessageType{}).Decode(ctx, buf); err != nil {
		return UnionField{}, err
	}
	frozen := string(buf)
	return *(*UnionField)(unsafe_.Pointer(&frozen)), nil
}

func (m UnionField) Name() idol.Text { return m.msg.GetText(1) }

func (m UnionField) Tag() uint16 { return uint16(m.msg.GetUint32(2)) }

func (m UnionField) Type() Type { return Type(m.msg.GetUint32(3)) }

func (m UnionField) TypeName() idol.Text { return m.msg.GetText(4) }

func (m UnionField) ArrayLen() uint32 { return m.msg.GetUint32(5) }

func (m UnionField) Options() UnionFieldOptions {
	if v := m.msg.GetIndirect(6); len(v) > 0 {
		return *(*UnionFieldOptions)(unsafe_.Pointer(&v))
	}
	return UnionFieldOptions{}
}

type UnionField__Builder struct {
	Name     idol.TextFieldBuilder
	Tag      idol.Uint16FieldBuilder
	Type     idol.EnumFieldBuilder[Type]
	TypeName idol.TextFieldBuilder
	ArrayLen idol.Uint32FieldBuilder
	Options  idol.MessageFieldBuilder[UnionFieldOptions]
}

type _UnionField__Builder struct {
	idol.IsGeneratedMessageBuilder[UnionField]
	self *UnionField__Builder
}

func (b *UnionField__Builder) Idol__MessageBuilder() idol.MessageBuilder[UnionField] {
	return _UnionField__Builder{self: b}
}

func (m _UnionField__Builder) Self() idol.AsMessageBuilder[UnionField] { return m.self }

func (b _UnionField__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _UnionField__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Tag.IsPresent() {
		m.Scalar(2)
	}
	if b.self.Type.IsPresent() {
		m.Scalar(3)
	}
	if b.self.TypeName.IsPresent() {
		m.Indirect(4, b.self.TypeName.DataSize())
	}
	if b.self.ArrayLen.IsPresent() {
		m.Scalar(5)
	}
	if b.self.Options.IsPresent() {
		m.Indirect(6, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _UnionField__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [56]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 6:
		b.self.Options.PutThunk(ht[48:56])
		fallthrough
	case 5:
		b.self.ArrayLen.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.TypeName.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.Type.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Tag.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.TypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type Protocol struct{ msg idol.DecodedMessage }

type _Protocol__Message struct {
	idol.IsGeneratedMessage[Protocol]
	self Protocol
}

type _Protocol__MessageType struct {
	idol.IsGeneratedMessageType[Protocol]
}

func (m Protocol) Idol__Message() idol.Message[Protocol] {
	return _Protocol__Message{self: m}
}

func (Protocol) Idol__MessageType() idol.MessageType[Protocol] {
	return _Protocol__MessageType{}
}

func (m _Protocol__Message) Self() Protocol { return m.self }

func (m _Protocol__Message) Type() idol.MessageType[Protocol] {
	return _Protocol__MessageType{}
}

func (m _Protocol__Message) Size() uint32 { return m.self.msg.Size() }

func (m _Protocol__Message) Fields() idol.MessageFields {
	return _Protocol__MessageFields{m.self}
}

func (m _Protocol__Message) Clone() idol.MessageBuilder[Protocol] {
	b := &Protocol__Builder{}
	b.Name.Set(m.self.Name())
	if m.self.msg.Has(4) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	b.Rpcs.Extend(m.self.Rpcs())
	b.Events.Extend(m.self.Events())
	return b.Idol__MessageBuilder()
}

type _Protocol__MessageFields struct {
	self Protocol
}

func (f _Protocol__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "rpcs"
	case 3:
		return "events"
	case 4:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _Protocol__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _Protocol__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.Options()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Rpcs()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Events()) {
			return
		}
	}
}

func (_Protocol__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.MessageArray(2, (ProtocolRpc{}).Idol__MessageType().Decode)
	d.MessageArray(3, (ProtocolEvent{}).Idol__MessageType().Decode)
	d.Message(4, (ProtocolOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_Protocol__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (Protocol, error) {
	if err := (_Protocol__MessageType{}).Decode(ctx, buf); err != nil {
		return Protocol{}, err
	}
	frozen := string(buf)
	return *(*Protocol)(unsafe_.Pointer(&frozen)), nil
}

func (m Protocol) Name() idol.Text { return m.msg.GetText(1) }

func (m Protocol) Options() ProtocolOptions {
	if v := m.msg.GetIndirect(4); len(v) > 0 {
		return *(*ProtocolOptions)(unsafe_.Pointer(&v))
	}
	return ProtocolOptions{}
}

func (m Protocol) Rpcs() idol.MessageArray[ProtocolRpc] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[ProtocolRpc])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[ProtocolRpc]{}
}

func (m Protocol) Events() idol.MessageArray[ProtocolEvent] {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*idol.MessageArray[ProtocolEvent])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[ProtocolEvent]{}
}

type Protocol__Builder struct {
	Name    idol.TextFieldBuilder
	Options idol.MessageFieldBuilder[ProtocolOptions]
	Rpcs    idol.MessageArrayFieldBuilder[ProtocolRpc]
	Events  idol.MessageArrayFieldBuilder[ProtocolEvent]
}

type _Protocol__Builder struct {
	idol.IsGeneratedMessageBuilder[Protocol]
	self *Protocol__Builder
}

func (b *Protocol__Builder) Idol__MessageBuilder() idol.MessageBuilder[Protocol] {
	return _Protocol__Builder{self: b}
}

func (m _Protocol__Builder) Self() idol.AsMessageBuilder[Protocol] { return m.self }

func (b _Protocol__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _Protocol__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Rpcs.IsPresent() {
		m.Indirect(2, b.self.Rpcs.DataSize())
	}
	if b.self.Events.IsPresent() {
		m.Indirect(3, b.self.Events.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(4, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _Protocol__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [40]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 4:
		b.self.Options.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.Events.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Rpcs.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Rpcs.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Events.EncodeData(ctx, w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type ProtocolRpc struct{ msg idol.DecodedMessage }

type _ProtocolRpc__Message struct {
	idol.IsGeneratedMessage[ProtocolRpc]
	self ProtocolRpc
}

type _ProtocolRpc__MessageType struct {
	idol.IsGeneratedMessageType[ProtocolRpc]
}

func (m ProtocolRpc) Idol__Message() idol.Message[ProtocolRpc] {
	return _ProtocolRpc__Message{self: m}
}

func (ProtocolRpc) Idol__MessageType() idol.MessageType[ProtocolRpc] {
	return _ProtocolRpc__MessageType{}
}

func (m _ProtocolRpc__Message) Self() ProtocolRpc { return m.self }

func (m _ProtocolRpc__Message) Type() idol.MessageType[ProtocolRpc] {
	return _ProtocolRpc__MessageType{}
}

func (m _ProtocolRpc__Message) Size() uint32 { return m.self.msg.Size() }

func (m _ProtocolRpc__Message) Fields() idol.MessageFields {
	return _ProtocolRpc__MessageFields{m.self}
}

func (m _ProtocolRpc__Message) Clone() idol.MessageBuilder[ProtocolRpc] {
	b := &ProtocolRpc__Builder{}
	b.Name.Set(m.self.Name())
	if v, ok := m.self.Tag(); ok {
		b.Tag.Set(v)
	}
	b.RequestType.Set(m.self.RequestType())
	b.RequestTypeName.Set(m.self.RequestTypeName())
	b.RequestIsStream.Set(m.self.RequestIsStream())
	b.ResponseType.Set(m.self.ResponseType())
	b.ResponseTypeName.Set(m.self.ResponseTypeName())
	b.ResponseIsStream.Set(m.self.ResponseIsStream())
	if m.self.msg.Has(9) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _ProtocolRpc__MessageFields struct {
	self ProtocolRpc
}

func (f _ProtocolRpc__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "tag"
	case 3:
		return "request_type"
	case 4:
		return "request_type_name"
	case 5:
		return "request_is_stream"
	case 6:
		return "response_type"
	case 7:
		return "response_type_name"
	case 8:
		return "response_is_stream"
	case 9:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _ProtocolRpc__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _ProtocolRpc__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) {
			v, _ := f.self.Tag()
			if !yield(2, v) {
				return
			}
		}
		if f.Has(3) && !yield(3, f.self.RequestType()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.RequestTypeName()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.RequestIsStream()) {
			return
		}
		if f.Has(6) && !yield(6, f.self.ResponseType()) {
			return
		}
		if f.Has(7) && !yield(7, f.self.ResponseTypeName()) {
			return
		}
		if f.Has(8) && !yield(8, f.self.ResponseIsStream()) {
			return
		}
		if f.Has(9) && !yield(9, f.self.Options()) {
			return
		}
	}
}

func (_ProtocolRpc__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint64(2)
	d.Uint8(3)
	d.Text(4)
	d.Bool(5)
	d.Uint8(6)
	d.Text(7)
	d.Bool(8)
	d.Message(9, (ProtocolRpcOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_ProtocolRpc__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (ProtocolRpc, error) {
	if err := (_ProtocolRpc__MessageType{}).Decode(ctx, buf); err != nil {
		return ProtocolRpc{}, err
	}
	frozen := string(buf)
	return *(*ProtocolRpc)(unsafe_.Pointer(&frozen)), nil
}

func (m ProtocolRpc) Name() idol.Text { return m.msg.GetText(1) }

func (m ProtocolRpc) Tag() (uint64, bool) {
	if m.msg.Has(2) {
		return m.msg.GetUint64(2), true
	}
	return 0, false
}

func (m ProtocolRpc) RequestType() Type { return Type(m.msg.GetUint32(3)) }

func (m ProtocolRpc) RequestTypeName() idol.Text { return m.msg.GetText(4) }

func (m ProtocolRpc) RequestIsStream() bool { return m.msg.GetBool(5) }

func (m ProtocolRpc) ResponseType() Type { return Type(m.msg.GetUint32(6)) }

func (m ProtocolRpc) ResponseTypeName() idol.Text { return m.msg.GetText(7) }

func (m ProtocolRpc) ResponseIsStream() bool { return m.msg.GetBool(8) }

func (m ProtocolRpc) Options() ProtocolRpcOptions {
	if v := m.msg.GetIndirect(9); len(v) > 0 {
		return *(*ProtocolRpcOptions)(unsafe_.Pointer(&v))
	}
	return ProtocolRpcOptions{}
}

type ProtocolRpc__Builder struct {
	Name             idol.TextFieldBuilder
	Tag              idol.Uint64FieldBuilder
	RequestType      idol.EnumFieldBuilder[Type]
	RequestTypeName  idol.TextFieldBuilder
	RequestIsStream  idol.BoolFieldBuilder
	ResponseType     idol.EnumFieldBuilder[Type]
	ResponseTypeName idol.TextFieldBuilder
	ResponseIsStream idol.BoolFieldBuilder
	Options          idol.MessageFieldBuilder[ProtocolRpcOptions]
}

type _ProtocolRpc__Builder struct {
	idol.IsGeneratedMessageBuilder[ProtocolRpc]
	self *ProtocolRpc__Builder
}

func (b *ProtocolRpc__Builder) Idol__MessageBuilder() idol.MessageBuilder[ProtocolRpc] {
	return _ProtocolRpc__Builder{self: b}
}

func (m _ProtocolRpc__Builder) Self() idol.AsMessageBuilder[ProtocolRpc] { return m.self }

func (b _ProtocolRpc__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _ProtocolRpc__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Tag.IsPresent() {
		m.Indirect(2, b.self.Tag.DataSize())
	}
	if b.self.RequestType.IsPresent() {
		m.Scalar(3)
	}
	if b.self.RequestTypeName.IsPresent() {
		m.Indirect(4, b.self.RequestTypeName.DataSize())
	}
	if b.self.RequestIsStream.IsPresent() {
		m.Scalar(5)
	}
	if b.self.ResponseType.IsPresent() {
		m.Scalar(6)
	}
	if b.self.ResponseTypeName.IsPresent() {
		m.Indirect(7, b.self.ResponseTypeName.DataSize())
	}
	if b.self.ResponseIsStream.IsPresent() {
		m.Scalar(8)
	}
	if b.self.Options.IsPresent() {
		m.Indirect(9, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _ProtocolRpc__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [80]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 9:
		b.self.Options.PutThunk(ht[72:80])
		fallthrough
	case 8:
		b.self.ResponseIsStream.PutThunk(ht[64:72])
		fallthrough
	case 7:
		b.self.ResponseTypeName.PutThunk(ht[56:64])
		fallthrough
	case 6:
		b.self.ResponseType.PutThunk(ht[48:56])
		fallthrough
	case 5:
		b.self.RequestIsStream.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.RequestTypeName.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.RequestType.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Tag.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Tag.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.RequestTypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.ResponseTypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type ProtocolEvent struct{ msg idol.DecodedMessage }

type _ProtocolEvent__Message struct {
	idol.IsGeneratedMessage[ProtocolEvent]
	self ProtocolEvent
}

type _ProtocolEvent__MessageType struct {
	idol.IsGeneratedMessageType[ProtocolEvent]
}

func (m ProtocolEvent) Idol__Message() idol.Message[ProtocolEvent] {
	return _ProtocolEvent__Message{self: m}
}

func (ProtocolEvent) Idol__MessageType() idol.MessageType[ProtocolEvent] {
	return _ProtocolEvent__MessageType{}
}

func (m _ProtocolEvent__Message) Self() ProtocolEvent { return m.self }

func (m _ProtocolEvent__Message) Type() idol.MessageType[ProtocolEvent] {
	return _ProtocolEvent__MessageType{}
}

func (m _ProtocolEvent__Message) Size() uint32 { return m.self.msg.Size() }

func (m _ProtocolEvent__Message) Fields() idol.MessageFields {
	return _ProtocolEvent__MessageFields{m.self}
}

func (m _ProtocolEvent__Message) Clone() idol.MessageBuilder[ProtocolEvent] {
	b := &ProtocolEvent__Builder{}
	b.Name.Set(m.self.Name())
	if v, ok := m.self.Tag(); ok {
		b.Tag.Set(v)
	}
	b.PayloadType.Set(m.self.PayloadType())
	b.PayloadTypeName.Set(m.self.PayloadTypeName())
	if m.self.msg.Has(5) {
		b.Options.Set(idol.Clone(m.self.Options()).Self())
	}
	return b.Idol__MessageBuilder()
}

type _ProtocolEvent__MessageFields struct {
	self ProtocolEvent
}

func (f _ProtocolEvent__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "tag"
	case 3:
		return "payload_type"
	case 4:
		return "payload_type_name"
	case 5:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _ProtocolEvent__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _ProtocolEvent__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) {
			v, _ := f.self.Tag()
			if !yield(2, v) {
				return
			}
		}
		if f.Has(3) && !yield(3, f.self.PayloadType()) {
			return
		}
		if f.Has(4) && !yield(4, f.self.PayloadTypeName()) {
			return
		}
		if f.Has(5) && !yield(5, f.self.Options()) {
			return
		}
	}
}

func (_ProtocolEvent__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint64(2)
	d.Uint8(3)
	d.Text(4)
	d.Message(5, (ProtocolEventOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_ProtocolEvent__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (ProtocolEvent, error) {
	if err := (_ProtocolEvent__MessageType{}).Decode(ctx, buf); err != nil {
		return ProtocolEvent{}, err
	}
	frozen := string(buf)
	return *(*ProtocolEvent)(unsafe_.Pointer(&frozen)), nil
}

func (m ProtocolEvent) Name() idol.Text { return m.msg.GetText(1) }

func (m ProtocolEvent) Tag() (uint64, bool) {
	if m.msg.Has(2) {
		return m.msg.GetUint64(2), true
	}
	return 0, false
}

func (m ProtocolEvent) PayloadType() Type { return Type(m.msg.GetUint32(3)) }

func (m ProtocolEvent) PayloadTypeName() idol.Text { return m.msg.GetText(4) }

func (m ProtocolEvent) Options() ProtocolEventOptions {
	if v := m.msg.GetIndirect(5); len(v) > 0 {
		return *(*ProtocolEventOptions)(unsafe_.Pointer(&v))
	}
	return ProtocolEventOptions{}
}

type ProtocolEvent__Builder struct {
	Name            idol.TextFieldBuilder
	Tag             idol.Uint64FieldBuilder
	PayloadType     idol.EnumFieldBuilder[Type]
	PayloadTypeName idol.TextFieldBuilder
	Options         idol.MessageFieldBuilder[ProtocolEventOptions]
}

type _ProtocolEvent__Builder struct {
	idol.IsGeneratedMessageBuilder[ProtocolEvent]
	self *ProtocolEvent__Builder
}

func (b *ProtocolEvent__Builder) Idol__MessageBuilder() idol.MessageBuilder[ProtocolEvent] {
	return _ProtocolEvent__Builder{self: b}
}

func (m _ProtocolEvent__Builder) Self() idol.AsMessageBuilder[ProtocolEvent] { return m.self }

func (b _ProtocolEvent__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _ProtocolEvent__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Tag.IsPresent() {
		m.Indirect(2, b.self.Tag.DataSize())
	}
	if b.self.PayloadType.IsPresent() {
		m.Scalar(3)
	}
	if b.self.PayloadTypeName.IsPresent() {
		m.Indirect(4, b.self.PayloadTypeName.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(5, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _ProtocolEvent__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [48]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 5:
		b.self.Options.PutThunk(ht[40:48])
		fallthrough
	case 4:
		b.self.PayloadTypeName.PutThunk(ht[32:40])
		fallthrough
	case 3:
		b.self.PayloadType.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Tag.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Tag.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.PayloadTypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type SchemaOptions struct{ msg idol.DecodedMessage }

type _SchemaOptions__Message struct {
	idol.IsGeneratedMessage[SchemaOptions]
	self SchemaOptions
}

type _SchemaOptions__MessageType struct {
	idol.IsGeneratedMessageType[SchemaOptions]
}

func (m SchemaOptions) Idol__Message() idol.Message[SchemaOptions] {
	return _SchemaOptions__Message{self: m}
}

func (SchemaOptions) Idol__MessageType() idol.MessageType[SchemaOptions] {
	return _SchemaOptions__MessageType{}
}

func (m _SchemaOptions__Message) Self() SchemaOptions { return m.self }

func (m _SchemaOptions__Message) Type() idol.MessageType[SchemaOptions] {
	return _SchemaOptions__MessageType{}
}

func (m _SchemaOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _SchemaOptions__Message) Fields() idol.MessageFields {
	return _SchemaOptions__MessageFields{m.self}
}

func (m _SchemaOptions__Message) Clone() idol.MessageBuilder[SchemaOptions] {
	b := &SchemaOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _SchemaOptions__MessageFields struct {
	self SchemaOptions
}

func (f _SchemaOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _SchemaOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _SchemaOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_SchemaOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_SchemaOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (SchemaOptions, error) {
	if err := (_SchemaOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return SchemaOptions{}, err
	}
	frozen := string(buf)
	return *(*SchemaOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m SchemaOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type SchemaOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _SchemaOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[SchemaOptions]
	self *SchemaOptions__Builder
}

func (b *SchemaOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[SchemaOptions] {
	return _SchemaOptions__Builder{self: b}
}

func (m _SchemaOptions__Builder) Self() idol.AsMessageBuilder[SchemaOptions] { return m.self }

func (b _SchemaOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _SchemaOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _SchemaOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type ConstOptions struct{ msg idol.DecodedMessage }

type _ConstOptions__Message struct {
	idol.IsGeneratedMessage[ConstOptions]
	self ConstOptions
}

type _ConstOptions__MessageType struct {
	idol.IsGeneratedMessageType[ConstOptions]
}

func (m ConstOptions) Idol__Message() idol.Message[ConstOptions] {
	return _ConstOptions__Message{self: m}
}

func (ConstOptions) Idol__MessageType() idol.MessageType[ConstOptions] {
	return _ConstOptions__MessageType{}
}

func (m _ConstOptions__Message) Self() ConstOptions { return m.self }

func (m _ConstOptions__Message) Type() idol.MessageType[ConstOptions] {
	return _ConstOptions__MessageType{}
}

func (m _ConstOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _ConstOptions__Message) Fields() idol.MessageFields {
	return _ConstOptions__MessageFields{m.self}
}

func (m _ConstOptions__Message) Clone() idol.MessageBuilder[ConstOptions] {
	b := &ConstOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _ConstOptions__MessageFields struct {
	self ConstOptions
}

func (f _ConstOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _ConstOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _ConstOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_ConstOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_ConstOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (ConstOptions, error) {
	if err := (_ConstOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return ConstOptions{}, err
	}
	frozen := string(buf)
	return *(*ConstOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m ConstOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type ConstOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _ConstOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[ConstOptions]
	self *ConstOptions__Builder
}

func (b *ConstOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[ConstOptions] {
	return _ConstOptions__Builder{self: b}
}

func (m _ConstOptions__Builder) Self() idol.AsMessageBuilder[ConstOptions] { return m.self }

func (b _ConstOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _ConstOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _ConstOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type EnumOptions struct{ msg idol.DecodedMessage }

type _EnumOptions__Message struct {
	idol.IsGeneratedMessage[EnumOptions]
	self EnumOptions
}

type _EnumOptions__MessageType struct {
	idol.IsGeneratedMessageType[EnumOptions]
}

func (m EnumOptions) Idol__Message() idol.Message[EnumOptions] {
	return _EnumOptions__Message{self: m}
}

func (EnumOptions) Idol__MessageType() idol.MessageType[EnumOptions] {
	return _EnumOptions__MessageType{}
}

func (m _EnumOptions__Message) Self() EnumOptions { return m.self }

func (m _EnumOptions__Message) Type() idol.MessageType[EnumOptions] {
	return _EnumOptions__MessageType{}
}

func (m _EnumOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _EnumOptions__Message) Fields() idol.MessageFields {
	return _EnumOptions__MessageFields{m.self}
}

func (m _EnumOptions__Message) Clone() idol.MessageBuilder[EnumOptions] {
	b := &EnumOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _EnumOptions__MessageFields struct {
	self EnumOptions
}

func (f _EnumOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _EnumOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _EnumOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_EnumOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_EnumOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (EnumOptions, error) {
	if err := (_EnumOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return EnumOptions{}, err
	}
	frozen := string(buf)
	return *(*EnumOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m EnumOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type EnumOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _EnumOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[EnumOptions]
	self *EnumOptions__Builder
}

func (b *EnumOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[EnumOptions] {
	return _EnumOptions__Builder{self: b}
}

func (m _EnumOptions__Builder) Self() idol.AsMessageBuilder[EnumOptions] { return m.self }

func (b _EnumOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _EnumOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _EnumOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type EnumItemOptions struct{ msg idol.DecodedMessage }

type _EnumItemOptions__Message struct {
	idol.IsGeneratedMessage[EnumItemOptions]
	self EnumItemOptions
}

type _EnumItemOptions__MessageType struct {
	idol.IsGeneratedMessageType[EnumItemOptions]
}

func (m EnumItemOptions) Idol__Message() idol.Message[EnumItemOptions] {
	return _EnumItemOptions__Message{self: m}
}

func (EnumItemOptions) Idol__MessageType() idol.MessageType[EnumItemOptions] {
	return _EnumItemOptions__MessageType{}
}

func (m _EnumItemOptions__Message) Self() EnumItemOptions { return m.self }

func (m _EnumItemOptions__Message) Type() idol.MessageType[EnumItemOptions] {
	return _EnumItemOptions__MessageType{}
}

func (m _EnumItemOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _EnumItemOptions__Message) Fields() idol.MessageFields {
	return _EnumItemOptions__MessageFields{m.self}
}

func (m _EnumItemOptions__Message) Clone() idol.MessageBuilder[EnumItemOptions] {
	b := &EnumItemOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _EnumItemOptions__MessageFields struct {
	self EnumItemOptions
}

func (f _EnumItemOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _EnumItemOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _EnumItemOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_EnumItemOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_EnumItemOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (EnumItemOptions, error) {
	if err := (_EnumItemOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return EnumItemOptions{}, err
	}
	frozen := string(buf)
	return *(*EnumItemOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m EnumItemOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type EnumItemOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _EnumItemOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[EnumItemOptions]
	self *EnumItemOptions__Builder
}

func (b *EnumItemOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[EnumItemOptions] {
	return _EnumItemOptions__Builder{self: b}
}

func (m _EnumItemOptions__Builder) Self() idol.AsMessageBuilder[EnumItemOptions] { return m.self }

func (b _EnumItemOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _EnumItemOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _EnumItemOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type StructOptions struct{ msg idol.DecodedMessage }

type _StructOptions__Message struct {
	idol.IsGeneratedMessage[StructOptions]
	self StructOptions
}

type _StructOptions__MessageType struct {
	idol.IsGeneratedMessageType[StructOptions]
}

func (m StructOptions) Idol__Message() idol.Message[StructOptions] {
	return _StructOptions__Message{self: m}
}

func (StructOptions) Idol__MessageType() idol.MessageType[StructOptions] {
	return _StructOptions__MessageType{}
}

func (m _StructOptions__Message) Self() StructOptions { return m.self }

func (m _StructOptions__Message) Type() idol.MessageType[StructOptions] {
	return _StructOptions__MessageType{}
}

func (m _StructOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _StructOptions__Message) Fields() idol.MessageFields {
	return _StructOptions__MessageFields{m.self}
}

func (m _StructOptions__Message) Clone() idol.MessageBuilder[StructOptions] {
	b := &StructOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _StructOptions__MessageFields struct {
	self StructOptions
}

func (f _StructOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _StructOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _StructOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_StructOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_StructOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (StructOptions, error) {
	if err := (_StructOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return StructOptions{}, err
	}
	frozen := string(buf)
	return *(*StructOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m StructOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type StructOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _StructOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[StructOptions]
	self *StructOptions__Builder
}

func (b *StructOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[StructOptions] {
	return _StructOptions__Builder{self: b}
}

func (m _StructOptions__Builder) Self() idol.AsMessageBuilder[StructOptions] { return m.self }

func (b _StructOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _StructOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _StructOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type StructFieldOptions struct{ msg idol.DecodedMessage }

type _StructFieldOptions__Message struct {
	idol.IsGeneratedMessage[StructFieldOptions]
	self StructFieldOptions
}

type _StructFieldOptions__MessageType struct {
	idol.IsGeneratedMessageType[StructFieldOptions]
}

func (m StructFieldOptions) Idol__Message() idol.Message[StructFieldOptions] {
	return _StructFieldOptions__Message{self: m}
}

func (StructFieldOptions) Idol__MessageType() idol.MessageType[StructFieldOptions] {
	return _StructFieldOptions__MessageType{}
}

func (m _StructFieldOptions__Message) Self() StructFieldOptions { return m.self }

func (m _StructFieldOptions__Message) Type() idol.MessageType[StructFieldOptions] {
	return _StructFieldOptions__MessageType{}
}

func (m _StructFieldOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _StructFieldOptions__Message) Fields() idol.MessageFields {
	return _StructFieldOptions__MessageFields{m.self}
}

func (m _StructFieldOptions__Message) Clone() idol.MessageBuilder[StructFieldOptions] {
	b := &StructFieldOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _StructFieldOptions__MessageFields struct {
	self StructFieldOptions
}

func (f _StructFieldOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _StructFieldOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _StructFieldOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_StructFieldOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_StructFieldOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (StructFieldOptions, error) {
	if err := (_StructFieldOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return StructFieldOptions{}, err
	}
	frozen := string(buf)
	return *(*StructFieldOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m StructFieldOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type StructFieldOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _StructFieldOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[StructFieldOptions]
	self *StructFieldOptions__Builder
}

func (b *StructFieldOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[StructFieldOptions] {
	return _StructFieldOptions__Builder{self: b}
}

func (m _StructFieldOptions__Builder) Self() idol.AsMessageBuilder[StructFieldOptions] { return m.self }

func (b _StructFieldOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _StructFieldOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _StructFieldOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type MessageOptions struct{ msg idol.DecodedMessage }

type _MessageOptions__Message struct {
	idol.IsGeneratedMessage[MessageOptions]
	self MessageOptions
}

type _MessageOptions__MessageType struct {
	idol.IsGeneratedMessageType[MessageOptions]
}

func (m MessageOptions) Idol__Message() idol.Message[MessageOptions] {
	return _MessageOptions__Message{self: m}
}

func (MessageOptions) Idol__MessageType() idol.MessageType[MessageOptions] {
	return _MessageOptions__MessageType{}
}

func (m _MessageOptions__Message) Self() MessageOptions { return m.self }

func (m _MessageOptions__Message) Type() idol.MessageType[MessageOptions] {
	return _MessageOptions__MessageType{}
}

func (m _MessageOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _MessageOptions__Message) Fields() idol.MessageFields {
	return _MessageOptions__MessageFields{m.self}
}

func (m _MessageOptions__Message) Clone() idol.MessageBuilder[MessageOptions] {
	b := &MessageOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _MessageOptions__MessageFields struct {
	self MessageOptions
}

func (f _MessageOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _MessageOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _MessageOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_MessageOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_MessageOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (MessageOptions, error) {
	if err := (_MessageOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return MessageOptions{}, err
	}
	frozen := string(buf)
	return *(*MessageOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m MessageOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type MessageOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _MessageOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[MessageOptions]
	self *MessageOptions__Builder
}

func (b *MessageOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[MessageOptions] {
	return _MessageOptions__Builder{self: b}
}

func (m _MessageOptions__Builder) Self() idol.AsMessageBuilder[MessageOptions] { return m.self }

func (b _MessageOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _MessageOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _MessageOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type MessageFieldOptions struct{ msg idol.DecodedMessage }

type _MessageFieldOptions__Message struct {
	idol.IsGeneratedMessage[MessageFieldOptions]
	self MessageFieldOptions
}

type _MessageFieldOptions__MessageType struct {
	idol.IsGeneratedMessageType[MessageFieldOptions]
}

func (m MessageFieldOptions) Idol__Message() idol.Message[MessageFieldOptions] {
	return _MessageFieldOptions__Message{self: m}
}

func (MessageFieldOptions) Idol__MessageType() idol.MessageType[MessageFieldOptions] {
	return _MessageFieldOptions__MessageType{}
}

func (m _MessageFieldOptions__Message) Self() MessageFieldOptions { return m.self }

func (m _MessageFieldOptions__Message) Type() idol.MessageType[MessageFieldOptions] {
	return _MessageFieldOptions__MessageType{}
}

func (m _MessageFieldOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _MessageFieldOptions__Message) Fields() idol.MessageFields {
	return _MessageFieldOptions__MessageFields{m.self}
}

func (m _MessageFieldOptions__Message) Clone() idol.MessageBuilder[MessageFieldOptions] {
	b := &MessageFieldOptions__Builder{}
	b.Optional.Set(m.self.Optional())
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _MessageFieldOptions__MessageFields struct {
	self MessageFieldOptions
}

func (f _MessageFieldOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "optional"
	case 3:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _MessageFieldOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _MessageFieldOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Optional()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_MessageFieldOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Bool(2)
	d.MessageArray(3, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_MessageFieldOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (MessageFieldOptions, error) {
	if err := (_MessageFieldOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return MessageFieldOptions{}, err
	}
	frozen := string(buf)
	return *(*MessageFieldOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m MessageFieldOptions) Optional() bool { return m.msg.GetBool(2) }

func (m MessageFieldOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type MessageFieldOptions__Builder struct {
	Optional      idol.BoolFieldBuilder
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _MessageFieldOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[MessageFieldOptions]
	self *MessageFieldOptions__Builder
}

func (b *MessageFieldOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[MessageFieldOptions] {
	return _MessageFieldOptions__Builder{self: b}
}

func (m _MessageFieldOptions__Builder) Self() idol.AsMessageBuilder[MessageFieldOptions] {
	return m.self
}

func (b _MessageFieldOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _MessageFieldOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Optional.IsPresent() {
		m.Scalar(2)
	}
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(3, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _MessageFieldOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.Uninterpreted.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Optional.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type UnionOptions struct{ msg idol.DecodedMessage }

type _UnionOptions__Message struct {
	idol.IsGeneratedMessage[UnionOptions]
	self UnionOptions
}

type _UnionOptions__MessageType struct {
	idol.IsGeneratedMessageType[UnionOptions]
}

func (m UnionOptions) Idol__Message() idol.Message[UnionOptions] {
	return _UnionOptions__Message{self: m}
}

func (UnionOptions) Idol__MessageType() idol.MessageType[UnionOptions] {
	return _UnionOptions__MessageType{}
}

func (m _UnionOptions__Message) Self() UnionOptions { return m.self }

func (m _UnionOptions__Message) Type() idol.MessageType[UnionOptions] {
	return _UnionOptions__MessageType{}
}

func (m _UnionOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _UnionOptions__Message) Fields() idol.MessageFields {
	return _UnionOptions__MessageFields{m.self}
}

func (m _UnionOptions__Message) Clone() idol.MessageBuilder[UnionOptions] {
	b := &UnionOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _UnionOptions__MessageFields struct {
	self UnionOptions
}

func (f _UnionOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _UnionOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _UnionOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_UnionOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_UnionOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (UnionOptions, error) {
	if err := (_UnionOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return UnionOptions{}, err
	}
	frozen := string(buf)
	return *(*UnionOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m UnionOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type UnionOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _UnionOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[UnionOptions]
	self *UnionOptions__Builder
}

func (b *UnionOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[UnionOptions] {
	return _UnionOptions__Builder{self: b}
}

func (m _UnionOptions__Builder) Self() idol.AsMessageBuilder[UnionOptions] { return m.self }

func (b _UnionOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _UnionOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _UnionOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type UnionFieldOptions struct{ msg idol.DecodedMessage }

type _UnionFieldOptions__Message struct {
	idol.IsGeneratedMessage[UnionFieldOptions]
	self UnionFieldOptions
}

type _UnionFieldOptions__MessageType struct {
	idol.IsGeneratedMessageType[UnionFieldOptions]
}

func (m UnionFieldOptions) Idol__Message() idol.Message[UnionFieldOptions] {
	return _UnionFieldOptions__Message{self: m}
}

func (UnionFieldOptions) Idol__MessageType() idol.MessageType[UnionFieldOptions] {
	return _UnionFieldOptions__MessageType{}
}

func (m _UnionFieldOptions__Message) Self() UnionFieldOptions { return m.self }

func (m _UnionFieldOptions__Message) Type() idol.MessageType[UnionFieldOptions] {
	return _UnionFieldOptions__MessageType{}
}

func (m _UnionFieldOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _UnionFieldOptions__Message) Fields() idol.MessageFields {
	return _UnionFieldOptions__MessageFields{m.self}
}

func (m _UnionFieldOptions__Message) Clone() idol.MessageBuilder[UnionFieldOptions] {
	b := &UnionFieldOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _UnionFieldOptions__MessageFields struct {
	self UnionFieldOptions
}

func (f _UnionFieldOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _UnionFieldOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _UnionFieldOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_UnionFieldOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_UnionFieldOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (UnionFieldOptions, error) {
	if err := (_UnionFieldOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return UnionFieldOptions{}, err
	}
	frozen := string(buf)
	return *(*UnionFieldOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m UnionFieldOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type UnionFieldOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _UnionFieldOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[UnionFieldOptions]
	self *UnionFieldOptions__Builder
}

func (b *UnionFieldOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[UnionFieldOptions] {
	return _UnionFieldOptions__Builder{self: b}
}

func (m _UnionFieldOptions__Builder) Self() idol.AsMessageBuilder[UnionFieldOptions] { return m.self }

func (b _UnionFieldOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _UnionFieldOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _UnionFieldOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type ProtocolOptions struct{ msg idol.DecodedMessage }

type _ProtocolOptions__Message struct {
	idol.IsGeneratedMessage[ProtocolOptions]
	self ProtocolOptions
}

type _ProtocolOptions__MessageType struct {
	idol.IsGeneratedMessageType[ProtocolOptions]
}

func (m ProtocolOptions) Idol__Message() idol.Message[ProtocolOptions] {
	return _ProtocolOptions__Message{self: m}
}

func (ProtocolOptions) Idol__MessageType() idol.MessageType[ProtocolOptions] {
	return _ProtocolOptions__MessageType{}
}

func (m _ProtocolOptions__Message) Self() ProtocolOptions { return m.self }

func (m _ProtocolOptions__Message) Type() idol.MessageType[ProtocolOptions] {
	return _ProtocolOptions__MessageType{}
}

func (m _ProtocolOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _ProtocolOptions__Message) Fields() idol.MessageFields {
	return _ProtocolOptions__MessageFields{m.self}
}

func (m _ProtocolOptions__Message) Clone() idol.MessageBuilder[ProtocolOptions] {
	b := &ProtocolOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _ProtocolOptions__MessageFields struct {
	self ProtocolOptions
}

func (f _ProtocolOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _ProtocolOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _ProtocolOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_ProtocolOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_ProtocolOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (ProtocolOptions, error) {
	if err := (_ProtocolOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return ProtocolOptions{}, err
	}
	frozen := string(buf)
	return *(*ProtocolOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m ProtocolOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type ProtocolOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _ProtocolOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[ProtocolOptions]
	self *ProtocolOptions__Builder
}

func (b *ProtocolOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[ProtocolOptions] {
	return _ProtocolOptions__Builder{self: b}
}

func (m _ProtocolOptions__Builder) Self() idol.AsMessageBuilder[ProtocolOptions] { return m.self }

func (b _ProtocolOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _ProtocolOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _ProtocolOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type ProtocolRpcOptions struct{ msg idol.DecodedMessage }

type _ProtocolRpcOptions__Message struct {
	idol.IsGeneratedMessage[ProtocolRpcOptions]
	self ProtocolRpcOptions
}

type _ProtocolRpcOptions__MessageType struct {
	idol.IsGeneratedMessageType[ProtocolRpcOptions]
}

func (m ProtocolRpcOptions) Idol__Message() idol.Message[ProtocolRpcOptions] {
	return _ProtocolRpcOptions__Message{self: m}
}

func (ProtocolRpcOptions) Idol__MessageType() idol.MessageType[ProtocolRpcOptions] {
	return _ProtocolRpcOptions__MessageType{}
}

func (m _ProtocolRpcOptions__Message) Self() ProtocolRpcOptions { return m.self }

func (m _ProtocolRpcOptions__Message) Type() idol.MessageType[ProtocolRpcOptions] {
	return _ProtocolRpcOptions__MessageType{}
}

func (m _ProtocolRpcOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _ProtocolRpcOptions__Message) Fields() idol.MessageFields {
	return _ProtocolRpcOptions__MessageFields{m.self}
}

func (m _ProtocolRpcOptions__Message) Clone() idol.MessageBuilder[ProtocolRpcOptions] {
	b := &ProtocolRpcOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _ProtocolRpcOptions__MessageFields struct {
	self ProtocolRpcOptions
}

func (f _ProtocolRpcOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _ProtocolRpcOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _ProtocolRpcOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_ProtocolRpcOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_ProtocolRpcOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (ProtocolRpcOptions, error) {
	if err := (_ProtocolRpcOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return ProtocolRpcOptions{}, err
	}
	frozen := string(buf)
	return *(*ProtocolRpcOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m ProtocolRpcOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type ProtocolRpcOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _ProtocolRpcOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[ProtocolRpcOptions]
	self *ProtocolRpcOptions__Builder
}

func (b *ProtocolRpcOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[ProtocolRpcOptions] {
	return _ProtocolRpcOptions__Builder{self: b}
}

func (m _ProtocolRpcOptions__Builder) Self() idol.AsMessageBuilder[ProtocolRpcOptions] { return m.self }

func (b _ProtocolRpcOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _ProtocolRpcOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _ProtocolRpcOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type ProtocolEventOptions struct{ msg idol.DecodedMessage }

type _ProtocolEventOptions__Message struct {
	idol.IsGeneratedMessage[ProtocolEventOptions]
	self ProtocolEventOptions
}

type _ProtocolEventOptions__MessageType struct {
	idol.IsGeneratedMessageType[ProtocolEventOptions]
}

func (m ProtocolEventOptions) Idol__Message() idol.Message[ProtocolEventOptions] {
	return _ProtocolEventOptions__Message{self: m}
}

func (ProtocolEventOptions) Idol__MessageType() idol.MessageType[ProtocolEventOptions] {
	return _ProtocolEventOptions__MessageType{}
}

func (m _ProtocolEventOptions__Message) Self() ProtocolEventOptions { return m.self }

func (m _ProtocolEventOptions__Message) Type() idol.MessageType[ProtocolEventOptions] {
	return _ProtocolEventOptions__MessageType{}
}

func (m _ProtocolEventOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _ProtocolEventOptions__Message) Fields() idol.MessageFields {
	return _ProtocolEventOptions__MessageFields{m.self}
}

func (m _ProtocolEventOptions__Message) Clone() idol.MessageBuilder[ProtocolEventOptions] {
	b := &ProtocolEventOptions__Builder{}
	b.Uninterpreted.Extend(m.self.Uninterpreted())
	return b.Idol__MessageBuilder()
}

type _ProtocolEventOptions__MessageFields struct {
	self ProtocolEventOptions
}

func (f _ProtocolEventOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 2:
		return "uninterpreted"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _ProtocolEventOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _ProtocolEventOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(2) && !yield(2, f.self.Uninterpreted()) {
			return
		}
	}
}

func (_ProtocolEventOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.MessageArray(2, (UninterpretedOptions{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_ProtocolEventOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (ProtocolEventOptions, error) {
	if err := (_ProtocolEventOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return ProtocolEventOptions{}, err
	}
	frozen := string(buf)
	return *(*ProtocolEventOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m ProtocolEventOptions) Uninterpreted() idol.MessageArray[UninterpretedOptions] {
	if v := m.msg.GetIndirect(2); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOptions])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOptions]{}
}

type ProtocolEventOptions__Builder struct {
	Uninterpreted idol.MessageArrayFieldBuilder[UninterpretedOptions]
}

type _ProtocolEventOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[ProtocolEventOptions]
	self *ProtocolEventOptions__Builder
}

func (b *ProtocolEventOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[ProtocolEventOptions] {
	return _ProtocolEventOptions__Builder{self: b}
}

func (m _ProtocolEventOptions__Builder) Self() idol.AsMessageBuilder[ProtocolEventOptions] {
	return m.self
}

func (b _ProtocolEventOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _ProtocolEventOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Uninterpreted.IsPresent() {
		m.Indirect(2, b.self.Uninterpreted.DataSize())
	}
	return m.Finish()
}

func (b _ProtocolEventOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [24]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 2:
		b.self.Uninterpreted.PutThunk(ht[16:24])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Uninterpreted.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type UninterpretedOptions struct{ msg idol.DecodedMessage }

type _UninterpretedOptions__Message struct {
	idol.IsGeneratedMessage[UninterpretedOptions]
	self UninterpretedOptions
}

type _UninterpretedOptions__MessageType struct {
	idol.IsGeneratedMessageType[UninterpretedOptions]
}

func (m UninterpretedOptions) Idol__Message() idol.Message[UninterpretedOptions] {
	return _UninterpretedOptions__Message{self: m}
}

func (UninterpretedOptions) Idol__MessageType() idol.MessageType[UninterpretedOptions] {
	return _UninterpretedOptions__MessageType{}
}

func (m _UninterpretedOptions__Message) Self() UninterpretedOptions { return m.self }

func (m _UninterpretedOptions__Message) Type() idol.MessageType[UninterpretedOptions] {
	return _UninterpretedOptions__MessageType{}
}

func (m _UninterpretedOptions__Message) Size() uint32 { return m.self.msg.Size() }

func (m _UninterpretedOptions__Message) Fields() idol.MessageFields {
	return _UninterpretedOptions__MessageFields{m.self}
}

func (m _UninterpretedOptions__Message) Clone() idol.MessageBuilder[UninterpretedOptions] {
	b := &UninterpretedOptions__Builder{}
	b.SchemaType.Set(m.self.SchemaType())
	b.SchemaTypeName.Set(m.self.SchemaTypeName())
	b.Options.Extend(m.self.Options())
	return b.Idol__MessageBuilder()
}

type _UninterpretedOptions__MessageFields struct {
	self UninterpretedOptions
}

func (f _UninterpretedOptions__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "schema_type"
	case 2:
		return "schema_type_name"
	case 3:
		return "options"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _UninterpretedOptions__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _UninterpretedOptions__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.SchemaType()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.SchemaTypeName()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Options()) {
			return
		}
	}
}

func (_UninterpretedOptions__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Uint8(1)
	d.Text(2)
	d.MessageArray(3, (UninterpretedOption{}).Idol__MessageType().Decode)
	return d.Finish()
}

func (_UninterpretedOptions__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (UninterpretedOptions, error) {
	if err := (_UninterpretedOptions__MessageType{}).Decode(ctx, buf); err != nil {
		return UninterpretedOptions{}, err
	}
	frozen := string(buf)
	return *(*UninterpretedOptions)(unsafe_.Pointer(&frozen)), nil
}

func (m UninterpretedOptions) SchemaType() Type { return Type(m.msg.GetUint32(1)) }

func (m UninterpretedOptions) SchemaTypeName() idol.Text { return m.msg.GetText(2) }

func (m UninterpretedOptions) Options() idol.MessageArray[UninterpretedOption] {
	if v := m.msg.GetIndirect(3); len(v) > 0 {
		return *(*idol.MessageArray[UninterpretedOption])(unsafe_.Pointer(&v))
	}
	return idol.MessageArray[UninterpretedOption]{}
}

type UninterpretedOptions__Builder struct {
	SchemaType     idol.EnumFieldBuilder[Type]
	SchemaTypeName idol.TextFieldBuilder
	Options        idol.MessageArrayFieldBuilder[UninterpretedOption]
}

type _UninterpretedOptions__Builder struct {
	idol.IsGeneratedMessageBuilder[UninterpretedOptions]
	self *UninterpretedOptions__Builder
}

func (b *UninterpretedOptions__Builder) Idol__MessageBuilder() idol.MessageBuilder[UninterpretedOptions] {
	return _UninterpretedOptions__Builder{self: b}
}

func (m _UninterpretedOptions__Builder) Self() idol.AsMessageBuilder[UninterpretedOptions] {
	return m.self
}

func (b _UninterpretedOptions__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _UninterpretedOptions__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.SchemaType.IsPresent() {
		m.Scalar(1)
	}
	if b.self.SchemaTypeName.IsPresent() {
		m.Indirect(2, b.self.SchemaTypeName.DataSize())
	}
	if b.self.Options.IsPresent() {
		m.Indirect(3, b.self.Options.DataSize())
	}
	return m.Finish()
}

func (b _UninterpretedOptions__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.Options.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.SchemaTypeName.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.SchemaType.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.SchemaTypeName.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Options.EncodeData(ctx, w); err != nil {
		return err
	}
	return nil
}

type UninterpretedOption struct{ msg idol.DecodedMessage }

type _UninterpretedOption__Message struct {
	idol.IsGeneratedMessage[UninterpretedOption]
	self UninterpretedOption
}

type _UninterpretedOption__MessageType struct {
	idol.IsGeneratedMessageType[UninterpretedOption]
}

func (m UninterpretedOption) Idol__Message() idol.Message[UninterpretedOption] {
	return _UninterpretedOption__Message{self: m}
}

func (UninterpretedOption) Idol__MessageType() idol.MessageType[UninterpretedOption] {
	return _UninterpretedOption__MessageType{}
}

func (m _UninterpretedOption__Message) Self() UninterpretedOption { return m.self }

func (m _UninterpretedOption__Message) Type() idol.MessageType[UninterpretedOption] {
	return _UninterpretedOption__MessageType{}
}

func (m _UninterpretedOption__Message) Size() uint32 { return m.self.msg.Size() }

func (m _UninterpretedOption__Message) Fields() idol.MessageFields {
	return _UninterpretedOption__MessageFields{m.self}
}

func (m _UninterpretedOption__Message) Clone() idol.MessageBuilder[UninterpretedOption] {
	b := &UninterpretedOption__Builder{}
	b.Name.Set(m.self.Name())
	b.Type.Set(m.self.Type())
	b.Value.Extend(m.self.Value())
	return b.Idol__MessageBuilder()
}

type _UninterpretedOption__MessageFields struct {
	self UninterpretedOption
}

func (f _UninterpretedOption__MessageFields) Name(tag uint16) string {
	switch tag {
	case 1:
		return "name"
	case 2:
		return "type"
	case 3:
		return "value"
	default:
		return fmt_.Sprintf("@%d", tag)
	}
}

func (f _UninterpretedOption__MessageFields) Has(tag uint16) bool {
	return f.self.msg.Has(tag)
}

func (f _UninterpretedOption__MessageFields) Values() iter_.Seq2[uint16, any] {
	return func(yield func(uint16, any) bool) {
		if f.Has(1) && !yield(1, f.self.Name()) {
			return
		}
		if f.Has(2) && !yield(2, f.self.Type()) {
			return
		}
		if f.Has(3) && !yield(3, f.self.Value()) {
			return
		}
	}
}

func (_UninterpretedOption__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {
	d := idol.NewMessageDecoder(ctx, buf)
	d.Text(1)
	d.Uint8(2)
	d.Uint8Array(3)
	return d.Finish()
}

func (_UninterpretedOption__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (UninterpretedOption, error) {
	if err := (_UninterpretedOption__MessageType{}).Decode(ctx, buf); err != nil {
		return UninterpretedOption{}, err
	}
	frozen := string(buf)
	return *(*UninterpretedOption)(unsafe_.Pointer(&frozen)), nil
}

func (m UninterpretedOption) Name() idol.Text { return m.msg.GetText(1) }

func (m UninterpretedOption) Type() Type { return Type(m.msg.GetUint32(2)) }

func (m UninterpretedOption) Value() idol.Uint8Array { return m.msg.GetUint8Array(3) }

type UninterpretedOption__Builder struct {
	Name  idol.TextFieldBuilder
	Type  idol.EnumFieldBuilder[Type]
	Value idol.Uint8ArrayFieldBuilder
}

type _UninterpretedOption__Builder struct {
	idol.IsGeneratedMessageBuilder[UninterpretedOption]
	self *UninterpretedOption__Builder
}

func (b *UninterpretedOption__Builder) Idol__MessageBuilder() idol.MessageBuilder[UninterpretedOption] {
	return _UninterpretedOption__Builder{self: b}
}

func (m _UninterpretedOption__Builder) Self() idol.AsMessageBuilder[UninterpretedOption] {
	return m.self
}

func (b _UninterpretedOption__Builder) Size() uint32 {
	size, _ := b.messageSize()
	return size
}

func (b _UninterpretedOption__Builder) messageSize() (uint32, uint16) {
	var m idol.MessageSizeBuilder
	if b.self.Name.IsPresent() {
		m.Indirect(1, b.self.Name.DataSize())
	}
	if b.self.Type.IsPresent() {
		m.Scalar(2)
	}
	if b.self.Value.IsPresent() {
		m.Indirect(3, b.self.Value.DataSize())
	}
	return m.Finish()
}

func (b _UninterpretedOption__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {
	size, thunkCount := b.messageSize()
	if size == 0 {
		return nil
	}
	var ht [32]uint8
	binary_.LittleEndian.PutUint32(ht[0:4], size)
	binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)
	switch thunkCount {
	case 3:
		b.self.Value.PutThunk(ht[24:32])
		fallthrough
	case 2:
		b.self.Type.PutThunk(ht[16:24])
		fallthrough
	case 1:
		b.self.Name.PutThunk(ht[8:16])
		fallthrough
	case 0:
	}
	if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {
		return err
	}
	if err := b.self.Name.EncodeData(w); err != nil {
		return err
	}
	if err := b.self.Value.EncodeData(w); err != nil {
		return err
	}
	return nil
}
