// Copyright (c) 2024 John Millikin <john@john-millikin.com>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
// OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.
//
// SPDX-License-Identifier: 0BSD

package main

import (
	"bytes"
	"errors"
	"fmt"
	"path"
	"slices"
	"strings"

	"go.idol-lang.org/idol/schema_idl"
)

type codegen struct {
	schema        schema_idl.Schema
	dependencies  []schema_idl.Schema
	pluginOptions []schema_idl.UninterpretedOptions

	schemaPath []string
	imports    map[string]string
	goPackage  string
	buf        bytes.Buffer
	output     []uint8
}

func (c *codegen) w(s string) {
	c.buf.WriteString(s)
}

func (c *codegen) wl(s string) {
	c.buf.WriteString(s)
	c.buf.WriteByte('\n')
}

func (c *codegen) wf(format string, a ...any) {
	c.w(fmt.Sprintf(format, a...))
}

func (c *codegen) wlf(format string, a ...any) {
	c.wl(fmt.Sprintf(format, a...))
}

func (c *codegen) emitSchema() error {
	if len(c.schemaPath) == 0 {
		c.schemaPath = c.schema.SourcePath().Collect()
	}

	if err := c.decideGoPackage(); err != nil {
		return err
	}

	namespaces := make(map[string]string)
	for _, dep := range c.dependencies {
		if depPkg := schemaGoPackage(dep); depPkg != "" {
			namespaces[dep.Namespace()] = depPkg
		}
	}

	c.wl(`// Code generated by idol-codegen-go. DO NOT EDIT.`)
	if len(c.schemaPath) > 0 {
		c.wlf(`// source: %s`, strings.Join(c.schemaPath, "/"))
	}
	c.wl(``)
	c.wlf(`package %s`, path.Base(c.goPackage))
	c.wl(`
import (
	binary_ "encoding/binary"
	fmt_ "fmt"
	io_ "io"
	iter_ "iter"
	unsafe_ "unsafe"

	"go.idol-lang.org/idol"
`)

	c.imports = make(map[string]string)
	importIdx := 0
	for _, import_ := range c.schema.Imports().Iter() {
		ns := import_.Namespace()
		if goPkg, ok := namespaces[ns]; ok {
			importIdent := fmt.Sprintf("import_%d_", importIdx)
			importIdx += 1
			c.wlf(`%s %q`, importIdent, goPkg)
			c.imports[ns] = importIdent
		}
	}
	c.wl(`)`)

	for _, enum := range c.schema.Enums().Iter() {
		if err := c.emitEnum(enum); err != nil {
			return err
		}
		c.wl(``)
	}
	for _, message := range c.schema.Messages().Iter() {
		if err := c.emitMessage(message); err != nil {
			return err
		}
		c.wl(``)
	}

	c.output = c.buf.Bytes()
	return nil
}

const _GO_SCHEMA_OPTIONS = "idol/codegen-options/go\x1FSchemaOptions"

func schemaGoPackage(schema schema_idl.Schema) string {
	// TODO: Validation, error handling, duplicate detection.
	for _, options := range schema.Options().Uninterpreted().Iter() {
		if options.SchemaTypeName() != _GO_SCHEMA_OPTIONS {
			continue
		}
		for _, opt := range options.Options().Iter() {
			if opt.Name() != "package" {
				continue
			}
			raw := string(opt.Value().Collect())
			return raw[1 : len(raw)-1]
		}
	}
	return ""
}

func (c *codegen) decideGoPackage() error {
	goPackage := schemaGoPackage(c.schema)
	if goPackage == "" && len(c.schemaPath) > 0 {
		filename := c.schemaPath[len(c.schemaPath)-1]
		if s, ok := strings.CutSuffix(filename, ".idol"); ok {
			goPackage = s + "_idl"
		} else if s, ok := strings.CutSuffix(filename, ".idl"); ok {
			goPackage = s + "_idl"
		}
		// FIXME: validate that `goPackage` is a valid Go identifier,
		// without using "go/token" because it bloats the WASM binary.
	}
	if goPackage == "" {
		return errors.New("Unable to determine the Go package name")
	}
	c.goPackage = goPackage
	return nil
}

func (c *codegen) localName(named interface{ Name() string }) string {
	return c.goName(named.Name())
}

func (c *codegen) typeName(typeName string) string {
	if namespace, typeName, ok := strings.Cut(typeName, "\x1F"); ok {
		import_, ok := c.imports[namespace]
		if !ok {
			// FIXME
			panic(fmt.Sprintf("no import for namespace %q", namespace))
		}
		return fmt.Sprintf("%s.%s", import_, c.goName(typeName))
	}
	return c.goName(typeName)
}

func (c *codegen) goName(name string) string {
	var buf strings.Builder
	upper := true
	for _, c := range name {
		if upper {
			buf.WriteString(strings.ToUpper(string(c)))
			upper = false
		} else if c == '_' {
			upper = true
		} else {
			buf.WriteRune(c)
		}
	}
	return buf.String()
}

func (c *codegen) enumTypeName(enum schema_idl.Enum) string {
	switch enum.Type() {
	case schema_idl.Type_U8:
		return "uint8"
	default:
		panic("todo")
	}
}

func (*codegen) hasData(type_ schema_idl.Type, arrayLen uint32) bool {
	if arrayLen > 0 {
		return true
	}
	switch type_ {
	case schema_idl.Type_U64, schema_idl.Type_TEXT, schema_idl.Type_MESSAGE:
		return true
	}
	return false
}

func (*codegen) containsHandles(type_ schema_idl.Type) bool {
	switch type_ {
	case schema_idl.Type_HANDLE, schema_idl.Type_STRUCT, schema_idl.Type_MESSAGE, schema_idl.Type_UNION:
		return true
	}
	return false
}

func (c *codegen) emitEnum(enum schema_idl.Enum) error {
	name := c.localName(enum)
	goType := c.enumTypeName(enum)
	c.wlf(`type %s %s`, name, goType)
	c.wl(``)

	items := enum.Items()
	for ii, item := range items.Iter() {
		// TODO: signed enums
		if ii == 0 {
			c.wl(`const (`)
			c.wlf(`%s_%s %s = %v`, name, item.Name(), name, item.Value())
		} else {
			c.wlf(`%s_%s = %v`, name, item.Name(), item.Value())
		}
	}
	if items.Len() > 0 {
		c.wl(`)`)
	}
	c.wl(``)

	c.wlf(`func (e %s) String() string {`, name)
	c.wl(`switch e {`)
	for _, item := range items.Iter() {
		c.wlf(`case %s_%s:`, name, item.Name())
		c.wlf(`return %q`, item.Name())
	}
	c.wl(`default:`)
	c.wlf(`return fmt_.Sprintf("%s(%%d)", %s(e))`, name, goType)
	c.wl(`}}`)

	return nil
}

func (c *codegen) emitMessage(msg schema_idl.Message) error {
	name := c.localName(msg)

	var tags []uint16
	fieldsByTag := make(map[uint16]schema_idl.MessageField)
	for _, field := range msg.Fields().Iter() {
		tag := field.Tag()
		if _, conflict := fieldsByTag[tag]; conflict {
			panic("field number conflict")
		}
		fieldsByTag[tag] = field
		tags = append(tags, tag)
	}
	slices.Sort(tags)

	optional := make(map[uint16]bool)
	for _, field := range msg.Fields().Iter() {
		tag := field.Tag()
		optional[tag] = field.Options().Optional()
	}

	c.wlf(`type %s struct { msg idol.DecodedMessage }`, name)
	c.wl(``)

	c.wlf(`type _%s__Message struct {`, name)
	c.wlf(`idol.IsGeneratedMessage[%s]`, name)
	c.wlf(`self %s`, name)
	c.wl(`}`)
	c.wl(``)

	c.wlf(`type _%s__MessageType struct {`, name)
	c.wlf(`idol.IsGeneratedMessageType[%s]`, name)
	c.wl(`}`)
	c.wl(``)

	c.wlf(`func (m %s) Idol__Message() idol.Message[%s] {`, name, name)
	c.wlf(`return _%s__Message{self: m} }`, name)
	c.wl(``)

	c.wlf(`func (%s) Idol__MessageType() idol.MessageType[%s] {`, name, name)
	c.wlf(`return _%s__MessageType{} }`, name)
	c.wl(``)

	c.wlf(`func (m _%s__Message) Self() %s { return m.self }`, name, name)
	c.wl(``)

	c.wlf(`func (m _%s__Message) Type() idol.MessageType[%s] {`, name, name)
	c.wlf(`return _%s__MessageType{} }`, name)
	c.wl(``)

	c.wlf(`func (m _%s__Message) Size() uint32 { return m.self.msg.Size() }`, name)
	c.wl(``)

	c.wlf(`func (m _%s__Message) Fields() idol.MessageFields {`, name)
	c.wlf(`return _%s__MessageFields{m.self} }`, name)
	c.wl(``)

	c.wlf(`func (m _%s__Message) Clone() idol.MessageBuilder[%s] {`, name, name)
	c.wlf(`b := &%s__Builder{}`, name)
	for _, field := range msg.Fields().Iter() {
		fName := c.localName(field)
		if field.ArrayLen() > 0 {
			c.wlf(`b.%s.Extend(m.self.%s())`, fName, fName)
		} else if field.Type() == schema_idl.Type_MESSAGE {
			c.wlf(`if m.self.msg.Has(%d) {`, field.Tag())
			c.wlf(`b.%s.Set(idol.Clone(m.self.%s()).Self()) }`, fName, fName)
		} else if optional[field.Tag()] {
			c.wlf(`if v, ok := m.self.%s(); ok { b.%s.Set(v) }`, fName, fName)
		} else {
			c.wlf(`b.%s.Set(m.self.%s())`, fName, fName)
		}
	}
	c.wl(`return b.Idol__MessageBuilder() }`)
	c.wl(``)

	c.wlf(`type _%s__MessageFields struct {`, name)
	c.wlf(`self %s`, name)
	c.wl(`}`)
	c.wl(``)

	c.wlf(`func (f _%s__MessageFields) Name(tag uint16) string {`, name)
	c.wl(`switch tag {`)
	for _, tag := range tags {
		c.wlf(`case %d:`, tag)
		c.wlf(`return %q`, fieldsByTag[tag].Name())
	}
	c.wl(`default:`)
	c.wl(`return fmt_.Sprintf("@%d", tag) }}`)
	c.wl(``)

	c.wlf(`func (f _%s__MessageFields) Has(tag uint16) bool {`, name)
	c.wl(`return f.self.msg.Has(tag) }`)
	c.wl(``)

	c.wlf(`func (f _%s__MessageFields) Values() iter_.Seq2[uint16, any] {`, name)
	c.wl(`return func(yield func(uint16, any) bool) {`)
	for _, field := range msg.Fields().Iter() {
		tag := field.Tag()
		fName := c.localName(field)
		if optional[tag] {
			c.wlf(`if f.Has(%d) { v, _ := f.self.%s()`, tag, fName)
			c.wlf(`if !yield(%d, v) { return } }`, tag)
		} else {
			c.wlf(`if f.Has(%d) && !yield(%d, f.self.%s()) { return }`, tag, tag, fName)
		}
	}
	c.wl(`}}`)
	c.wl(``)

	c.wlf(`func (_%s__MessageType) Decode(ctx *idol.DecodeCtx, buf []uint8) error {`, name)
	c.wl(`d := idol.NewMessageDecoder(ctx, buf)`)
	for _, tag := range tags {
		field := fieldsByTag[tag]
		c.w(`d.`)
		switch field.Type() {
		case schema_idl.Type_TEXT:
			if field.ArrayLen() > 0 {
				c.wlf(`TextArray(%d)`, tag)
			} else {
				c.wlf(`Text(%d)`, tag)
			}
		case schema_idl.Type_MESSAGE:
			typeName := c.typeName(field.TypeName())
			if field.ArrayLen() > 0 {
				c.w(`MessageArray`)
			} else {
				c.w(`Message`)
			}
			c.wlf(`(%d, (%s{}).Idol__MessageType().Decode)`, tag, typeName)
		case schema_idl.Type_U8:
			if field.ArrayLen() > 0 {
				c.wlf(`Uint8Array(%d)`, tag)
			} else {
				c.wlf(`Uint8(%d)`, tag)
			}
		case schema_idl.Type_U16:
			if field.ArrayLen() > 0 {
				c.wlf(`Uint16Array(%d)`, tag)
			} else {
				c.wlf(`Uint16(%d)`, tag)
			}
		case schema_idl.Type_U32:
			if field.ArrayLen() > 0 {
				c.wlf(`Uint3Array(%d)`, tag)
			} else {
				c.wlf(`Uint32(%d)`, tag)
			}
		case schema_idl.Type_U64:
			if field.ArrayLen() > 0 {
				c.wlf(`Uint64Array(%d)`, tag)
			} else {
				c.wlf(`Uint64(%d)`, tag)
			}
		case schema_idl.Type_BOOL:
			if field.ArrayLen() > 0 {
				c.wlf(`BoolArray(%d)`, tag)
			} else {
				c.wlf(`Bool(%d)`, tag)
			}
		default:
			c.wl(`TODO_FIELD_TYPE`)
		}
	}
	c.wl(`return d.Finish() }`)
	c.wl(``)

	c.wlf(
		`func (_%s__MessageType) DecodeAs(ctx *idol.DecodeCtx, buf []uint8) (%s, error) {`,
		name, name,
	)
	c.wlf(`if err := (_%s__MessageType{}).Decode(ctx, buf); err != nil {`, name)
	c.wlf(`return %s{}, err }`, name)
	c.wl(`frozen := string(buf)`)
	c.wlf(`return *(*%s)(unsafe_.Pointer(&frozen)), nil }`, name)
	c.wl(``)

	for _, field := range msg.Fields().Iter() {
		fName := c.localName(field)
		tag := field.Tag()
		switch field.Type() {
		case schema_idl.Type_TEXT:
			if field.ArrayLen() > 0 {
				c.wlf(`func (m %s) %s() idol.TextArray { return m.msg.GetTextArray(%d) }`, name, fName, tag)
			} else {
				c.wlf(`func (m %s) %s() idol.Text { return m.msg.GetText(%d) }`, name, fName, tag)
			}
		case schema_idl.Type_MESSAGE:
			fType := c.typeName(field.TypeName())
			if field.ArrayLen() > 0 {
				c.wlf(`func (m %s) %s() idol.MessageArray[%s] {`, name, fName, fType)
				c.wlf(`if v := m.msg.GetIndirect(%d); len(v) > 0 {`, tag)
				c.wlf(`return *(*idol.MessageArray[%s])(unsafe_.Pointer(&v))`, fType)
				c.wl(`}`)
				c.wlf(`return idol.MessageArray[%s]{} }`, fType)
			} else {
				c.wlf(`func (m %s) %s() %s {`, name, fName, fType)
				c.wlf(`if v := m.msg.GetIndirect(%d); len(v) > 0 {`, tag)
				c.wlf(`return *(*%s)(unsafe_.Pointer(&v))`, fType)
				c.wl(`}`)
				c.wlf(`return %s{} }`, fType)
			}
		case schema_idl.Type_U8:
			if fType := field.TypeName(); fType == "" {
				if field.ArrayLen() > 0 {
					c.wlf(
						`func (m %s) %s() idol.Uint8Array { return m.msg.GetUint8Array(%d) }`,
						name, fName, tag,
					)
				} else {
					c.wlf(
						`func (m %s) %s() uint8 { return uint8(m.msg.GetUint32(%d)) }`,
						name, fName, tag,
					)
				}
			} else {
				if field.ArrayLen() > 0 {
					c.wl(`func TODO_FIELD_FN() {}`)
				} else {
					c.wlf(
						`func (m %s) %s() %s { return %s(m.msg.GetUint32(%d))}`,
						name, fName, fType, fType, tag,
					)
				}
			}
		case schema_idl.Type_U16:
			if fType := field.TypeName(); fType == "" {
				if field.ArrayLen() > 0 {
					c.wlf(
						`func (m %s) %s() idol.Uint16Array { return m.msg.GetUint16Array(%d) }`,
						name, fName, tag,
					)
				} else {
					c.wlf(
						`func (m %s) %s() uint16 { return uint16(m.msg.GetUint32(%d)) }`,
						name, fName, tag,
					)
				}
			} else {
				c.wl(`func TODO_FIELD_FN() {}`)
			}
		case schema_idl.Type_U32:
			if fType := field.TypeName(); fType == "" {
				if field.ArrayLen() > 0 {
					c.wlf(
						`func (m %s) %s() idol.Uint32Array { return m.msg.GetUint32Array(%d) }`,
						name, fName, tag,
					)
				} else {
					c.wlf(
						`func (m %s) %s() uint32 { return m.msg.GetUint32(%d) }`,
						name, fName, tag,
					)
				}
			} else {
				c.wl(`func TODO_FIELD_FN() {}`)
			}
		case schema_idl.Type_U64:
			if fType := field.TypeName(); fType == "" {
				if field.ArrayLen() > 0 {
					c.wlf(
						`func (m %s) %s() idol.Uint64Array { return m.msg.GetUint64Array(%d) }`,
						name, fName, tag,
					)
				} else if optional[tag] {
					c.wlf(`func (m %s) %s() (uint64, bool) {`, name, fName)
					c.wlf(`if m.msg.Has(%d) { return m.msg.GetUint64(%d), true }`, tag, tag)
					c.wl(`return 0, false }`)
				} else {
					c.wlf(
						`func (m %s) %s() uint64 { return m.msg.GetUint64(%d) }`,
						name, fName, tag,
					)
				}
			} else {
				if field.ArrayLen() > 0 {
					c.wl(`func TODO_FIELD_FN() {}`)
				} else {
					// TODO: u64 and i64 enums
					c.wlf(
						`func (m %s) %s() %s { return %s(m.msg.GetUint8(%d))}`,
						name, fName, fType, fType, tag,
					)
				}
			}
		case schema_idl.Type_BOOL:
			if field.ArrayLen() > 0 {
				c.wlf(
					`func (m %s) %s() idol.BoolArray { return m.msg.GetBoolArray(%d) }`,
					name, fName, tag,
				)
			} else {
				c.wlf(
					`func (m %s) %s() bool { return m.msg.GetBool(%d) }`,
					name, fName, tag,
				)
			}
		default:
			c.wl(`func TODO_FIELD_FN() {}`)
		}
		c.wl(``)
	}
	c.wl(``)

	c.wlf(`type %s__Builder struct {`, name)
	for _, field := range msg.Fields().Iter() {
		c.wf(`%s `, c.localName(field))
		switch field.Type() {
		case schema_idl.Type_TEXT:
			if field.ArrayLen() > 0 {
				c.wl(`idol.TextArrayFieldBuilder`)
			} else {
				c.wl(`idol.TextFieldBuilder`)
			}
		case schema_idl.Type_MESSAGE:
			fType := c.typeName(field.TypeName())
			if field.ArrayLen() > 0 {
				c.wlf(`idol.MessageArrayFieldBuilder[%s]`, fType)
			} else {
				c.wlf(`idol.MessageFieldBuilder[%s]`, fType)
			}
		case schema_idl.Type_U8:
			if fType := c.typeName(field.TypeName()); fType == "" {
				if field.ArrayLen() > 0 {
					c.wl(`idol.Uint8ArrayFieldBuilder`)
				} else {
					c.wl(`idol.Uint8FieldBuilder`)
				}
			} else {
				if field.ArrayLen() > 0 {
					c.wlf(`idol.EnumArrayFieldBuilder[%s]`, fType)
				} else {
					c.wlf(`idol.EnumFieldBuilder[%s]`, fType)
				}
			}
		case schema_idl.Type_U16:
			if fType := c.typeName(field.TypeName()); fType == "" {
				if field.ArrayLen() > 0 {
					c.wl(`idol.Uint16ArrayFieldBuilder`)
				} else {
					c.wl(`idol.Uint16FieldBuilder`)
				}
			} else {
				c.wl(`TODO_FIELD_TYPE`)
			}
		case schema_idl.Type_U32:
			if fType := c.typeName(field.TypeName()); fType == "" {
				if field.ArrayLen() > 0 {
					c.wl(`idol.Uint32ArrayFieldBuilder`)
				} else {
					c.wl(`idol.Uint32FieldBuilder`)
				}
			} else {
				c.wl(`TODO_FIELD_TYPE`)
			}
		case schema_idl.Type_U64:
			if fType := c.typeName(field.TypeName()); fType == "" {
				if field.ArrayLen() > 0 {
					c.wl(`idol.Uint64ArrayFieldBuilder`)
				} else {
					c.wl(`idol.Uint64FieldBuilder`)
				}
			} else {
				c.wl(`TODO_FIELD_TYPE`)
			}
		case schema_idl.Type_BOOL:
			if field.ArrayLen() > 0 {
				c.wl(`idol.BoolArrayFieldBuilder`)
			} else {
				c.wl(`idol.BoolFieldBuilder`)
			}
		default:
			c.wl(`TODO_FIELD_TYPE`)
		}
	}
	c.wl(`}`)
	c.wl(``)

	c.wlf(`type _%s__Builder struct {`, name)
	c.wlf(`idol.IsGeneratedMessageBuilder[%s]`, name)
	c.wlf(`self *%s__Builder }`, name)
	c.wl(``)

	c.wlf(`func (b *%s__Builder) Idol__MessageBuilder() idol.MessageBuilder[%s] {`, name, name)
	c.wlf(`return _%s__Builder{self: b}}`, name)
	c.wl(``)

	c.wlf(`func (m _%s__Builder) Self() idol.AsMessageBuilder[%s] { return m.self }`, name, name)
	c.wl(``)

	c.wlf(`func (b _%s__Builder) Size() uint32 {`, name)
	c.wl(`size, _ := b.messageSize(); return size }`)
	c.wl(``)

	c.wlf(`func (b _%s__Builder) messageSize() (uint32, uint16) {`, name)
	c.wl(`var m idol.MessageSizeBuilder`)
	for _, tag := range tags {
		field := fieldsByTag[tag]
		fName := c.localName(field)
		c.wlf(`if b.self.%s.IsPresent() {`, fName)
		if c.hasData(field.Type(), field.ArrayLen()) {
			c.wlf(`m.Indirect(%d, b.self.%s.DataSize()) }`, tag, fName)
		} else {
			c.wlf(`m.Scalar(%d) }`, tag)
		}
	}
	c.wl(`return m.Finish()`)
	c.wl(`}`)
	c.wl(``)

	c.wlf(`func (b _%s__Builder) EncodeTo(ctx *idol.EncodeCtx, w io_.Writer) error {`, name)
	c.wl(`size, thunkCount := b.messageSize()`)
	c.wl(`if size == 0 { return nil }`)

	headerThunkSize := 8 + uint32(slices.Max(tags))*8
	if headerThunkSize >= 1024 {
		c.wlf(`ht := make([]uint8, %d)`, headerThunkSize)
	} else {
		c.wlf(`var ht [%d]uint8`, headerThunkSize)
	}
	c.wl(`binary_.LittleEndian.PutUint32(ht[0:4], size)`)
	c.wl(`binary_.LittleEndian.PutUint16(ht[6:8], thunkCount)`)
	c.wl(`switch thunkCount {`)
	for _, tag := range slices.Backward(tags) {
		field := fieldsByTag[tag]
		fName := c.localName(field)
		c.wlf(`case %d:`, tag)
		c.wlf(`b.self.%s.PutThunk(ht[%d:%d])`, fName, tag*8, tag*8+8)
		c.wl(`fallthrough`)
	}
	c.wl(`case 0:`)
	c.wl(`}`)
	c.wl(`if _, err := w.Write(ht[:8+uint32(thunkCount)*8]); err != nil {`)
	c.wl(`return err }`)
	for _, tag := range tags {
		field := fieldsByTag[tag]
		if !c.hasData(field.Type(), field.ArrayLen()) {
			continue
		}
		fName := c.localName(field)
		c.wf(`if err := b.self.%s.EncodeData(`, fName)
		if c.containsHandles(field.Type()) {
			c.w(`ctx, `)
		}
		c.wlf(`w); err != nil { return err }`)
	}
	c.wl(`return nil }`)
	c.wl(``)

	return nil
}
